<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/ternjs/acorn"

    >acorn (v5.0.3)</a>
</h1>
<h4>ECMAScript parser</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn">module acorn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Node">
            function <span class="apidocSignatureSpan">acorn.</span>Node
            <span class="apidocSignatureSpan">(parser, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser">
            function <span class="apidocSignatureSpan">acorn.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Position">
            function <span class="apidocSignatureSpan">acorn.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.SourceLocation">
            function <span class="apidocSignatureSpan">acorn.</span>SourceLocation
            <span class="apidocSignatureSpan">(p, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.TokContext">
            function <span class="apidocSignatureSpan">acorn.</span>TokContext
            <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Token">
            function <span class="apidocSignatureSpan">acorn.</span>Token
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.TokenType">
            function <span class="apidocSignatureSpan">acorn.</span>TokenType
            <span class="apidocSignatureSpan">(label, conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.addLooseExports">
            function <span class="apidocSignatureSpan">acorn.</span>addLooseExports
            <span class="apidocSignatureSpan">(parse, Parser, plugins)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.getLineInfo">
            function <span class="apidocSignatureSpan">acorn.</span>getLineInfo
            <span class="apidocSignatureSpan">(input, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.isIdentifierChar">
            function <span class="apidocSignatureSpan">acorn.</span>isIdentifierChar
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.isIdentifierStart">
            function <span class="apidocSignatureSpan">acorn.</span>isIdentifierStart
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.isNewLine">
            function <span class="apidocSignatureSpan">acorn.</span>isNewLine
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.parse">
            function <span class="apidocSignatureSpan">acorn.</span>parse
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.parseExpressionAt">
            function <span class="apidocSignatureSpan">acorn.</span>parseExpressionAt
            <span class="apidocSignatureSpan">(input, pos, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.tokenizer">
            function <span class="apidocSignatureSpan">acorn.</span>tokenizer
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>Position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>defaultOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>keywordTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>lineBreak</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>lineBreakG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>nonASCIIwhitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>tokContexts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>tokTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">acorn.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Parser">module acorn.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.Parser">
            function <span class="apidocSignatureSpan">acorn.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Parser.prototype">module acorn.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.afterTrailingComma">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>afterTrailingComma
            <span class="apidocSignatureSpan">(tokType, notNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.braceIsBlock">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>braceIsBlock
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.buildBinary">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>buildBinary
            <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.canDeclareLexicalName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareLexicalName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.canDeclareVarName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareVarName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.canInsertSemicolon">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canInsertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExport
            <span class="apidocSignatureSpan">(exports, name, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkExpressionErrors">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExpressionErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkLVal">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkLVal
            <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkParams">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkParams
            <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkPatternErrors">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkPatternExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternExport
            <span class="apidocSignatureSpan">(exports, pat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkPropClash">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPropClash
            <span class="apidocSignatureSpan">(prop, propHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkVariableExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkVariableExport
            <span class="apidocSignatureSpan">(exports, decls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkYieldAwaitInDefaultParams">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkYieldAwaitInDefaultParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.curContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.curPosition">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curPosition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.declareLexicalName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareLexicalName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.declareVarName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareVarName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.eat">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eat
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.eatContextual">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eatContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.enterFunctionScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterFunctionScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.enterLexicalScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterLexicalScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.exitFunctionScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitFunctionScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.exitLexicalScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitLexicalScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.expectContextual">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expectContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.extend">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>extend
            <span class="apidocSignatureSpan">(name, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishNode">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishNodeAt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNodeAt
            <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishOp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishOp
            <span class="apidocSignatureSpan">(type, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishToken
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.fullCharCodeAtPos">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>fullCharCodeAtPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.getToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.getTokenFromCode">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getTokenFromCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.inGeneratorContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>inGeneratorContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.initFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.initialContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initialContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.insertSemicolon">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>insertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isAsyncFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isAsyncFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isContextual">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isKeyword">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isKeyword
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isLet">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isLet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isReservedWord">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isReservedWord
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isSimpleAssignTarget">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleAssignTarget
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isSimpleParamList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleParamList
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.loadPlugins">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>loadPlugins
            <span class="apidocSignatureSpan">(pluginConfigs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.next">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.nextToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseArrowExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseArrowExpression
            <span class="apidocSignatureSpan">(node, params, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseAwait">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseAwait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBindingAtom">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingAtom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBindingList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingList
            <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma, allowNonIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBindingListItem">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingListItem
            <span class="apidocSignatureSpan">(param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">(createNewLexicalScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBreakContinueStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBreakContinueStatement
            <span class="apidocSignatureSpan">(node, keyword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClass">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClass
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClassId">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassId
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClassMethod">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassMethod
            <span class="apidocSignatureSpan">(classBody, method, isGenerator, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClassSuper">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassSuper
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseDebuggerStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDebuggerStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseDoStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDoStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseEmptyStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseEmptyStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExport
            <span class="apidocSignatureSpan">(node, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExportSpecifiers">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExportSpecifiers
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprAtom">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprAtom
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprList
            <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprOp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOp
            <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprOps">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOps
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprSubscripts">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprSubscripts
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpression
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExpressionStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpressionStatement
            <span class="apidocSignatureSpan">(node, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFor">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFor
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseForIn">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForIn
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseForStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunction
            <span class="apidocSignatureSpan">(node, isStatement, allowExpressionBody, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunctionBody">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionBody
            <span class="apidocSignatureSpan">(node, isArrowFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunctionParams">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionParams
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunctionStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionStatement
            <span class="apidocSignatureSpan">(node, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseIdent">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIdent
            <span class="apidocSignatureSpan">(liberal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseIfStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIfStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseImport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImport
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseImportSpecifiers">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImportSpecifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseLabeledStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLabeledStatement
            <span class="apidocSignatureSpan">(node, maybeName, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseLiteral">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeAssign">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeAssign
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeConditional">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeConditional
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeDefault">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeDefault
            <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeUnary">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeUnary
            <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMethod">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMethod
            <span class="apidocSignatureSpan">(isGenerator, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseNew">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseNew
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseObj">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseObj
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenAndDistinguishExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenAndDistinguishExpression
            <span class="apidocSignatureSpan">(canBeArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenArrowList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenArrowList
            <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenItem">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenItem
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parsePropertyName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyName
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parsePropertyValue">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyValue
            <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseRest">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseRest
            <span class="apidocSignatureSpan">(allowNonIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseReturnStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseReturnStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseSpread">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSpread
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseStatement
            <span class="apidocSignatureSpan">(declaration, topLevel, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseSubscripts">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSubscripts
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseSwitchStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSwitchStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTemplate">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTemplateElement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplateElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseThrowStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseThrowStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTopLevel">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTopLevel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTryStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTryStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseVar">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVar
            <span class="apidocSignatureSpan">(node, isFor, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseVarId">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarId
            <span class="apidocSignatureSpan">(decl, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseVarStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarStatement
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseWhileStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWhileStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseWithStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWithStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseYield">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseYield
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.raise">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raise
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.raiseRecoverable">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raiseRecoverable
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readCodePoint">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readCodePoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readEscapedChar">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readEscapedChar
            <span class="apidocSignatureSpan">(inTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readHexChar">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readHexChar
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readInt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readInt
            <span class="apidocSignatureSpan">(radix, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readNumber">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readNumber
            <span class="apidocSignatureSpan">(startsWithDot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readRadixNumber">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRadixNumber
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readRegexp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRegexp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readString">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readString
            <span class="apidocSignatureSpan">(quote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readTmplToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readTmplToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_caret">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_caret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_dot">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_eq_excl">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_eq_excl
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_lt_gt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_lt_gt
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_mult_modulo_exp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_mult_modulo_exp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_pipe_amp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_pipe_amp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_plus_min">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_plus_min
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_slash">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_slash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readWord">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readWord1">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.semicolon">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.shouldParseExportStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>shouldParseExportStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.skipBlockComment">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipBlockComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.skipLineComment">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipLineComment
            <span class="apidocSignatureSpan">(startSkip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.skipSpace">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipSpace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.startNode">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.startNodeAt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNodeAt
            <span class="apidocSignatureSpan">(pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.strictDirective">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>strictDirective
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.toAssignable">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignable
            <span class="apidocSignatureSpan">(node, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.toAssignableList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignableList
            <span class="apidocSignatureSpan">(exprList, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.unexpected">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>unexpected
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.updateContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>updateContext
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Position">module acorn.Position</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Position.Position">
            function <span class="apidocSignatureSpan">acorn.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Position.prototype">module acorn.Position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Position.prototype.offset">
            function <span class="apidocSignatureSpan">acorn.Position.prototype.</span>offset
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn" id="apidoc.module.acorn">module acorn</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Node" id="apidoc.element.acorn.Node">
        function <span class="apidocSignatureSpan">acorn.</span>Node
        <span class="apidocSignatureSpan">(parser, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(parser, pos, loc) {
  this.type = &#x22;&#x22;
  this.start = pos
  this.end = 0
  if (parser.options.locations)
    this.loc = new SourceLocation(parser, loc)
  if (parser.options.directSourceFile)
    this.sourceFile = parser.options.directSourceFile
  if (parser.options.ranges)
    this.range = [pos, 0]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.inAsync = false
  // Load plugins
  this.options.pluginsLoose = options.pluginsLoose || {}
  this.loadPlugins(this.options.pluginsLoose)
};

LooseParser.prototype.startNode = function startNode () {
  return new __acorn.<span class="apidocCodeKeywordSpan">Node</span>(this.toks, this.tok.start, this.options.locations ? this.tok
.loc.start : null)
};

LooseParser.prototype.storeCurrentPos = function storeCurrentPos () {
  return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start
};

LooseParser.prototype.startNodeAt = function startNodeAt (pos) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser" id="apidoc.element.acorn.Parser">
        function <span class="apidocSignatureSpan">acorn.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options)
  this.sourceFile = options.sourceFile
  this.keywords = keywordRegexp(keywords[options.ecmaVersion &#x3e;= 6 ? 6 : 5])
  var reserved = &#x22;&#x22;
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      if (reserved = reservedWords[v]) break
    if (options.sourceType == &#x22;module&#x22;) reserved += &#x22; await&#x22;
  }
  this.reservedWords = keywordRegexp(reserved)
  var reservedStrict = (reserved ? reserved + &#x22; &#x22; : &#x22;&#x22;) + reservedWords.strict
  this.reservedWordsStrict = keywordRegexp(reservedStrict)
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + &#x22; &#x22; + reservedWords.strictBind)
  this.input = String(input)

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false

  // Load plugins
  this.loadPlugins(options.plugins)

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos
    this.lineStart = this.input.lastIndexOf(&#x22;\n&#x22;, startPos - 1) + 1
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
  } else {
    this.pos = this.lineStart = 0
    this.curLine = 1
  }

  // Properties of the current token:
  // Its type
  this.type = tt.eof
  // For tokens that include more information than their type, the value
  this.value = null
  // Its start and end offset
  this.start = this.end = this.pos
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition()

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null
  this.lastTokStart = this.lastTokEnd = this.pos

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext()
  this.exprAllowed = true

  // Figure out if it&#x27;s a module code.
  this.inModule = options.sourceType === &#x22;module&#x22;
  this.strict = this.inModule || this.strictDirective(this.pos)

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0
  // Labels in scope.
  this.labels = []

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &#x26;&#x26; options.allowHashBang &#x26;&#x26; this.input.slice(0, 2) === &#x22;#!&#x22;)
    this.skipLineComment(2)

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = []
  this.enterFunctionScope()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Position" id="apidoc.element.acorn.Position">
        function <span class="apidocSignatureSpan">acorn.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line
  this.column = col
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.SourceLocation" id="apidoc.element.acorn.SourceLocation">
        function <span class="apidocSignatureSpan">acorn.</span>SourceLocation
        <span class="apidocSignatureSpan">(p, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceLocation(p, start, end) {
  this.start = start
  this.end = end
  if (p.sourceFile !== null) this.source = p.sourceFile
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.toks = __acorn.tokenizer(input, options)
this.options = this.toks.options
this.input = this.toks.input
this.tok = this.last = {type: __acorn.tokTypes.eof, start: 0, end: 0}
if (this.options.locations) {
  var here = this.toks.curPosition()
  this.tok.loc = new __acorn.<span class="apidocCodeKeywordSpan">SourceLocation</span>(this.toks, here, here)
}
this.ahead = [] // Tokens ahead
this.context = [] // Indentation contexted
this.curIndent = 0
this.curLineStart = 0
this.nextLineStart = this.lineEnd(this.curLineStart) + 1
this.inAsync = false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.TokContext" id="apidoc.element.acorn.TokContext">
        function <span class="apidocSignatureSpan">acorn.</span>TokContext
        <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token
  this.isExpr = !!isExpr
  this.preserveSpace = !!preserveSpace
  this.override = override
  this.generator = !!generator
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Token" id="apidoc.element.acorn.Token">
        function <span class="apidocSignatureSpan">acorn.</span>Token
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(p) {
  this.type = p.type
  this.value = p.value
  this.start = p.start
  this.end = p.end
  if (p.options.locations)
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
  if (p.options.ranges)
    this.range = [p.start, p.end]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this$1.toks.next()
if (this$1.toks.type === __acorn.tokTypes.dot &#x26;&#x26;
    this$1.input.substr(this$1.toks.end, 1) === &#x22;.&#x22; &#x26;&#x26;
    this$1.options.ecmaVersion &#x3e;= 6) {
  this$1.toks.end++
  this$1.toks.type = __acorn.tokTypes.ellipsis
}
return new __acorn.<span class="apidocCodeKeywordSpan">Token</span>(this$1.toks)
    } catch (e) {
if (!(e instanceof SyntaxError)) throw e

// Try to skip some text, based on the error message, and then continue
var msg = e.message, pos = e.raisedAt, replace = true
if (/unterminated/i.test(msg)) {
  pos = this$1.lineEnd(e.pos + 1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.TokenType" id="apidoc.element.acorn.TokenType">
        function <span class="apidocSignatureSpan">acorn.</span>TokenType
        <span class="apidocSignatureSpan">(label, conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label
  this.keyword = conf.keyword
  this.beforeExpr = !!conf.beforeExpr
  this.startsExpr = !!conf.startsExpr
  this.isLoop = !!conf.isLoop
  this.isAssign = !!conf.isAssign
  this.prefix = !!conf.prefix
  this.postfix = !!conf.postfix
  this.binop = conf.binop || null
  this.updateContext = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.addLooseExports" id="apidoc.element.acorn.addLooseExports">
        function <span class="apidocSignatureSpan">acorn.</span>addLooseExports
        <span class="apidocSignatureSpan">(parse, Parser, plugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addLooseExports(parse, Parser, plugins) {
  exports.parse_dammit = parse // eslint-disable-line camelcase
  exports.LooseParser = Parser
  exports.pluginsLoose = plugins
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// eslint-disable-next-line camelcase
function parse_dammit(input, options) {
  var p = new LooseParser(input, options)
  p.next()
  return p.parseTopLevel()
}

__acorn.<span class="apidocCodeKeywordSpan">addLooseExports</span>(parse_dammit, LooseParser, pluginsLoose)

exports.parse_dammit = parse_dammit;
exports.LooseParser = LooseParser;
exports.pluginsLoose = pluginsLoose;

Object.defineProperty(exports, &#x27;__esModule&#x27;, { value: true });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.getLineInfo" id="apidoc.element.acorn.getLineInfo">
        function <span class="apidocSignatureSpan">acorn.</span>getLineInfo
        <span class="apidocSignatureSpan">(input, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur
    var match = lineBreakG.exec(input)
    if (match &#x26;&#x26; match.index &#x3c; offset) {
      ++line
      cur = match.index + match[0].length
    } else {
      return new Position(line, offset - cur)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      this$1.resetTo(pos)
      if (replace === true) replace = {start: pos, end: pos, type: __acorn.tokTypes.name, value: &#x22;✖&#x22;}
      if (replace) {
        if (this$1.options.locations)
          replace.loc = new __acorn.SourceLocation(
            this$1.toks,
            __acorn.<span class="apidocCodeKeywordSpan">getLineInfo</span>(this$1.input, replace.start),
            __acorn.getLineInfo(this$1.input, replace.end))
        return replace
      }
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.isIdentifierChar" id="apidoc.element.acorn.isIdentifierChar">
        function <span class="apidocSignatureSpan">acorn.</span>isIdentifierChar
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierChar(code, astral) {
  if (code &#x3c; 48) return code === 36
  if (code &#x3c; 58) return true
  if (code &#x3c; 65) return false
  if (code &#x3c; 91) return true
  if (code &#x3c; 97) return code === 95
  if (code &#x3c; 123) return true
  if (code &#x3c;= 0xffff) return code &#x3e;= 0xaa &#x26;&#x26; nonASCIIidentifier.test(String.fromCharCode(code))
  if (astral === false) return false
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.isIdentifierStart" id="apidoc.element.acorn.isIdentifierStart">
        function <span class="apidocSignatureSpan">acorn.</span>isIdentifierStart
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierStart(code, astral) {
  if (code &#x3c; 65) return code === 36
  if (code &#x3c; 91) return true
  if (code &#x3c; 97) return code === 95
  if (code &#x3c; 123) return true
  if (code &#x3c;= 0xffff) return code &#x3e;= 0xaa &#x26;&#x26; nonASCIIidentifierStart.test(String.fromCharCode(code))
  if (astral === false) return false
  return isInAstralSet(code, astralIdentifierStartCodes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.isNewLine" id="apidoc.element.acorn.isNewLine">
        function <span class="apidocSignatureSpan">acorn.</span>isNewLine
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

LooseParser.prototype.popCx = function popCx () {
this.curIndent = this.context.pop()
};

LooseParser.prototype.lineEnd = function lineEnd (pos) {
while (pos &#x3c; this.input.length &#x26;&#x26; !__acorn.<span class="apidocCodeKeywordSpan">isNewLine</span>(this.input.charCodeAt
(pos))) ++pos
return pos
};

LooseParser.prototype.indentationAfter = function indentationAfter (pos) {
  var this$1 = this;

for (var count = 0;; ++pos) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.parse" id="apidoc.element.acorn.parse">
        function <span class="apidocSignatureSpan">acorn.</span>parse
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(input, options) {
  return new Parser(options, input).parse()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Escodegen supports generating comments from AST, attached in
Esprima-specific format. In order to simulate same format in
Acorn, consider following example:

```javascript
var comments = [], tokens = [];

var ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>(&#x27;var x = 42; // answer&#x27;, {
	// collect ranges for each node
	ranges: true,
	// collect comments in Esprima&#x27;s format
	onComment: comments,
	// collect token ranges
	onToken: tokens
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.parseExpressionAt" id="apidoc.element.acorn.parseExpressionAt">
        function <span class="apidocSignatureSpan">acorn.</span>parseExpressionAt
        <span class="apidocSignatureSpan">(input, pos, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos)
  p.nextToken()
  return p.parseExpression()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.tokenizer" id="apidoc.element.acorn.tokenizer">
        function <span class="apidocSignatureSpan">acorn.</span>tokenizer
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenizer(input, options) {
  return new Parser(options, input)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
should stop calling the method, since it will keep returning that same
token forever.

In ES6 environment, returned result can be used as any other
protocol-compliant iterable:

```javascript
for (let token of acorn.<span class="apidocCodeKeywordSpan">tokenizer</span>(str)) {
  // iterate over the tokens
}

// transform code to array of tokens:
var tokens = [...acorn.tokenizer(str)];
```
...</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Parser" id="apidoc.module.acorn.Parser">module acorn.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Parser.Parser" id="apidoc.element.acorn.Parser.Parser">
        function <span class="apidocSignatureSpan">acorn.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options)
  this.sourceFile = options.sourceFile
  this.keywords = keywordRegexp(keywords[options.ecmaVersion &#x3e;= 6 ? 6 : 5])
  var reserved = &#x22;&#x22;
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      if (reserved = reservedWords[v]) break
    if (options.sourceType == &#x22;module&#x22;) reserved += &#x22; await&#x22;
  }
  this.reservedWords = keywordRegexp(reserved)
  var reservedStrict = (reserved ? reserved + &#x22; &#x22; : &#x22;&#x22;) + reservedWords.strict
  this.reservedWordsStrict = keywordRegexp(reservedStrict)
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + &#x22; &#x22; + reservedWords.strictBind)
  this.input = String(input)

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false

  // Load plugins
  this.loadPlugins(options.plugins)

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos
    this.lineStart = this.input.lastIndexOf(&#x22;\n&#x22;, startPos - 1) + 1
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
  } else {
    this.pos = this.lineStart = 0
    this.curLine = 1
  }

  // Properties of the current token:
  // Its type
  this.type = tt.eof
  // For tokens that include more information than their type, the value
  this.value = null
  // Its start and end offset
  this.start = this.end = this.pos
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition()

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null
  this.lastTokStart = this.lastTokEnd = this.pos

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext()
  this.exprAllowed = true

  // Figure out if it&#x27;s a module code.
  this.inModule = options.sourceType === &#x22;module&#x22;
  this.strict = this.inModule || this.strictDirective(this.pos)

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0
  // Labels in scope.
  this.labels = []

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &#x26;&#x26; options.allowHashBang &#x26;&#x26; this.input.slice(0, 2) === &#x22;#!&#x22;)
    this.skipLineComment(2)

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = []
  this.enterFunctionScope()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Parser.prototype" id="apidoc.module.acorn.Parser.prototype">module acorn.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.afterTrailingComma" id="apidoc.element.acorn.Parser.prototype.afterTrailingComma">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>afterTrailingComma
        <span class="apidocSignatureSpan">(tokType, notNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterTrailingComma = function (tokType, notNext) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma)
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
    if (!notNext)
      this.next()
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var nodes = [], first = true
  // export { x, y as z } [from &#x27;...&#x27;]
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
if (!first) {
  this$1.expect(tt.comma)
  if (this$1.<span class="apidocCodeKeywordSpan">afterTrailingComma</span>(tt.braceR)) break
} else first = false

var node = this$1.startNode()
node.local = this$1.parseIdent(true)
node.exported = this$1.eatContextual(&#x22;as&#x22;) ? this$1.parseIdent(true) : node.local
this$1.checkExport(exports, node.exported.name, node.exported.start)
nodes.push(this$1.finishNode(node, &#x22;ExportSpecifier&#x22;))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.braceIsBlock" id="apidoc.element.acorn.Parser.prototype.braceIsBlock">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>braceIsBlock
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">braceIsBlock = function (prevType) {
  if (prevType === tt.colon) {
    var parent = this.curContext()
    if (parent === types.b_stat || parent === types.b_expr)
      return !parent.isExpr
  }
  if (prevType === tt._return)
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR || prevType == tt.arrow)
    return true
  if (prevType == tt.braceL)
    return this.curContext() === types.b_stat
  return !this.exprAllowed
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.exprAllowed = true
  } else {
    this.exprAllowed = !out.isExpr
  }
}

tt.braceL.updateContext = function(prevType) {
  this.context.push(this.<span class="apidocCodeKeywordSpan">braceIsBlock</span>(prevType) ? types.b_stat : types.b_expr)
  this.exprAllowed = true
}

tt.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl)
  this.exprAllowed = true
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.buildBinary" id="apidoc.element.acorn.Parser.prototype.buildBinary">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>buildBinary
        <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc)
  node.left = left
  node.operator = op
  node.right = right
  return this.finishNode(node, logical ? &#x22;LogicalExpression&#x22; : &#x22;BinaryExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (prec != null &#x26;&#x26; (!noIn || this.type !== tt._in)) {
    if (prec &#x3e; minPrec) {
      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND
      var op = this.value
      this.next()
      var startPos = this.start, startLoc = this.startLoc
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)
      var node = this.<span class="apidocCodeKeywordSpan">buildBinary</span>(leftStartPos, leftStartLoc, left, right, op, logical
)
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
}

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.canDeclareLexicalName" id="apidoc.element.acorn.Parser.prototype.canDeclareLexicalName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareLexicalName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1]

  return !has(currentScope.lexical, name) &#x26;&#x26; !has(currentScope.var, name) &#x26;&#x26; !has(currentScope.childVar, name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (has(checkClashes, expr.name))
    this.raiseRecoverable(expr.start, &#x22;Argument name clash&#x22;)
  checkClashes[expr.name] = true
}
if (bindingType &#x26;&#x26; bindingType !== &#x22;none&#x22;) {
  if (
    bindingType === &#x22;var&#x22; &#x26;&#x26; !this.canDeclareVarName(expr.name) ||
    bindingType !== &#x22;var&#x22; &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">canDeclareLexicalName</span>(expr.name
)
  ) {
    this.raiseRecoverable(expr.start, (&#x22;Identifier &#x27;&#x22; + (expr.name) + &#x22;&#x27; has already been declared&#x22
;))
  }
  if (bindingType === &#x22;var&#x22;) {
    this.declareVarName(expr.name)
  } else {
    this.declareLexicalName(expr.name)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.canDeclareVarName" id="apidoc.element.acorn.Parser.prototype.canDeclareVarName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareVarName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1]

  return !has(currentScope.lexical, name) &#x26;&#x26; !has(currentScope.parentLexical, name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (checkClashes) {
  if (has(checkClashes, expr.name))
    this.raiseRecoverable(expr.start, &#x22;Argument name clash&#x22;)
  checkClashes[expr.name] = true
}
if (bindingType &#x26;&#x26; bindingType !== &#x22;none&#x22;) {
  if (
    bindingType === &#x22;var&#x22; &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">canDeclareVarName</span>(expr.name) ||
    bindingType !== &#x22;var&#x22; &#x26;&#x26; !this.canDeclareLexicalName(expr.name)
  ) {
    this.raiseRecoverable(expr.start, (&#x22;Identifier &#x27;&#x22; + (expr.name) + &#x22;&#x27; has already been declared&#x22
;))
  }
  if (bindingType === &#x22;var&#x22;) {
    this.declareVarName(expr.name)
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.canInsertSemicolon" id="apidoc.element.acorn.Parser.prototype.canInsertSemicolon">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canInsertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canInsertSemicolon = function () {
  return this.type === tt.eof ||
    this.type === tt.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.canInsertSemicolon = function() {
  return this.type === tt.eof ||
    this.type === tt.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}

pp.insertSemicolon = function() {
  if (this.<span class="apidocCodeKeywordSpan">canInsertSemicolon</span>()) {
    if (this.options.onInsertedSemicolon)
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
    return true
  }
}

// Consume a semicolon, or, failing that, see if we are allowed to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkExport" id="apidoc.element.acorn.Parser.prototype.checkExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExport
        <span class="apidocSignatureSpan">(exports, name, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkExport = function (exports, name, pos) {
  if (!exports) return
  if (has(exports, name))
    this.raiseRecoverable(pos, &#x22;Duplicate export &#x27;&#x22; + name + &#x22;&#x27;&#x22;)
  exports[name] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.eat(tt.star)) {
  this.expectContextual(&#x22;from&#x22;)
  node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  this.semicolon()
  return this.finishNode(node, &#x22;ExportAllDeclaration&#x22;)
}
if (this.eat(tt._default)) { // export default ...
  this.<span class="apidocCodeKeywordSpan">checkExport</span>(exports, &#x22;default&#x22;, this.lastTokStart)
  var isAsync
  if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode()
    this.next()
    if (isAsync) this.next()
    node.declaration = this.parseFunction(fNode, &#x22;nullableID&#x22;, false, isAsync)
  } else if (this.type === tt._class) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkExpressionErrors" id="apidoc.element.acorn.Parser.prototype.checkExpressionErrors">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExpressionErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1
  if (!andThrow) return pos &#x3e;= 0
  if (pos &#x3e; -1) this.raise(pos, &#x22;Shorthand property assignments are valid only in destructuring patterns&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var init = this.parseExpression(true, refDestructuringErrors)
if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
  this.toAssignable(init)
  this.checkLVal(init)
  this.checkPatternErrors(refDestructuringErrors, true)
  return this.parseForIn(node, init)
} else {
  this.<span class="apidocCodeKeywordSpan">checkExpressionErrors</span>(refDestructuringErrors, true)
}
return this.parseFor(node, init)
}

pp$1.parseFunctionStatement = function(node, isAsync) {
this.next()
return this.parseFunction(node, true, false, isAsync)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkLVal" id="apidoc.element.acorn.Parser.prototype.checkLVal">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkLVal
        <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkLVal = function (expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case &#x22;Identifier&#x22;:
    if (this.strict &#x26;&#x26; this.reservedWordsStrictBind.test(expr.name))
      this.raiseRecoverable(expr.start, (bindingType ? &#x22;Binding &#x22; : &#x22;Assigning to &#x22;) + expr.name + &#x22; in strict mode&#x22;)
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        this.raiseRecoverable(expr.start, &#x22;Argument name clash&#x22;)
      checkClashes[expr.name] = true
    }
    if (bindingType &#x26;&#x26; bindingType !== &#x22;none&#x22;) {
      if (
        bindingType === &#x22;var&#x22; &#x26;&#x26; !this.canDeclareVarName(expr.name) ||
        bindingType !== &#x22;var&#x22; &#x26;&#x26; !this.canDeclareLexicalName(expr.name)
      ) {
        this.raiseRecoverable(expr.start, (&#x22;Identifier &#x27;&#x22; + (expr.name) + &#x22;&#x27; has already been declared&#x22;))
      }
      if (bindingType === &#x22;var&#x22;) {
        this.declareVarName(expr.name)
      } else {
        this.declareLexicalName(expr.name)
      }
    }
    break

  case &#x22;MemberExpression&#x22;:
    if (bindingType) this.raiseRecoverable(expr.start, (bindingType ? &#x22;Binding&#x22; : &#x22;Assigning to&#x22;) + &#x22; member expression&#x22;)
    break

  case &#x22;ObjectPattern&#x22;:
    for (var i = 0; i &#x3c; expr.properties.length; i++)
      this$1.checkLVal(expr.properties[i].value, bindingType, checkClashes)
    break

  case &#x22;ArrayPattern&#x22;:
    for (var i$1 = 0; i$1 &#x3c; expr.elements.length; i$1++) {
      var elem = expr.elements[i$1]
      if (elem) this$1.checkLVal(elem, bindingType, checkClashes)
    }
    break

  case &#x22;AssignmentPattern&#x22;:
    this.checkLVal(expr.left, bindingType, checkClashes)
    break

  case &#x22;RestElement&#x22;:
    this.checkLVal(expr.argument, bindingType, checkClashes)
    break

  case &#x22;ParenthesizedExpression&#x22;:
    this.checkLVal(expr.expression, bindingType, checkClashes)
    break

  default:
    this.raise(expr.start, (bindingType ? &#x22;Binding&#x22; : &#x22;Assigning to&#x22;) + &#x22; rvalue&#x22;)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return this.parseForIn(node, init$1)
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors
  var init = this.parseExpression(true, refDestructuringErrors)
  if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
    this.toAssignable(init)
    this.<span class="apidocCodeKeywordSpan">checkLVal</span>(init)
    this.checkPatternErrors(refDestructuringErrors, true)
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true)
  }
  return this.parseFor(node, init)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkParams" id="apidoc.element.acorn.Parser.prototype.checkParams">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkParams
        <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkParams = function (node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {}
  for (var i = 0; i &#x3c; node.params.length; i++) this$1.checkLVal(node.params[i], &#x22;var&#x22;, allowDuplicates ? null : nameHash)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$3.parseFunctionBody = function(node, isArrowFunction) {
var isExpression = isArrowFunction &#x26;&#x26; this.type !== tt.braceL
var oldStrict = this.strict, useStrict = false

if (isExpression) {
  node.body = this.parseMaybeAssign()
  node.expression = true
  this.<span class="apidocCodeKeywordSpan">checkParams</span>(node, false)
} else {
  var nonSimple = this.options.ecmaVersion &#x3e;= 7 &#x26;&#x26; !this.isSimpleParamList(node.params)
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end)
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkPatternErrors" id="apidoc.element.acorn.Parser.prototype.checkPatternErrors">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) return
  if (refDestructuringErrors.trailingComma &#x3e; -1)
    this.raiseRecoverable(refDestructuringErrors.trailingComma, &#x22;Comma is not permitted after the rest element&#x22;)
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind
  if (parens &#x3e; -1) this.raiseRecoverable(parens, &#x22;Parenthesized pattern&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors
  var init = this.parseExpression(true, refDestructuringErrors)
  if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
    this.toAssignable(init)
    this.checkLVal(init)
    this.<span class="apidocCodeKeywordSpan">checkPatternErrors</span>(refDestructuringErrors, true)
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true)
  }
  return this.parseFor(node, init)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkPatternExport" id="apidoc.element.acorn.Parser.prototype.checkPatternExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternExport
        <span class="apidocSignatureSpan">(exports, pat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPatternExport = function (exports, pat) {
  var this$1 = this;

  var type = pat.type
  if (type == &#x22;Identifier&#x22;)
    this.checkExport(exports, pat.name, pat.start)
  else if (type == &#x22;ObjectPattern&#x22;)
    for (var i = 0; i &#x3c; pat.properties.length; ++i)
      this$1.checkPatternExport(exports, pat.properties[i].value)
  else if (type == &#x22;ArrayPattern&#x22;)
    for (var i$1 = 0; i$1 &#x3c; pat.elements.length; ++i$1) {
      var elt = pat.elements[i$1]
      if (elt) this$1.checkPatternExport(exports, elt)
    }
  else if (type == &#x22;AssignmentPattern&#x22;)
    this.checkPatternExport(exports, pat.left)
  else if (type == &#x22;ParenthesizedExpression&#x22;)
    this.checkPatternExport(exports, pat.expression)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var this$1 = this;

var type = pat.type
if (type == &#x22;Identifier&#x22;)
  this.checkExport(exports, pat.name, pat.start)
else if (type == &#x22;ObjectPattern&#x22;)
  for (var i = 0; i &#x3c; pat.properties.length; ++i)
    this$1.<span class="apidocCodeKeywordSpan">checkPatternExport</span>(exports, pat.properties[i].value)
else if (type == &#x22;ArrayPattern&#x22;)
  for (var i$1 = 0; i$1 &#x3c; pat.elements.length; ++i$1) {
    var elt = pat.elements[i$1]
    if (elt) this$1.checkPatternExport(exports, elt)
  }
else if (type == &#x22;AssignmentPattern&#x22;)
  this.checkPatternExport(exports, pat.left)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkPropClash" id="apidoc.element.acorn.Parser.prototype.checkPropClash">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPropClash
        <span class="apidocSignatureSpan">(prop, propHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; (prop.computed || prop.method || prop.shorthand))
    return
  var key = prop.key;
  var name
  switch (key.type) {
  case &#x22;Identifier&#x22;: name = key.name; break
  case &#x22;Literal&#x22;: name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion &#x3e;= 6) {
    if (name === &#x22;__proto__&#x22; &#x26;&#x26; kind === &#x22;init&#x22;) {
      if (propHash.proto) this.raiseRecoverable(key.start, &#x22;Redefinition of __proto__ property&#x22;)
      propHash.proto = true
    }
    return
  }
  name = &#x22;$&#x22; + name
  var other = propHash[name]
  if (other) {
    var redefinition
    if (kind === &#x22;init&#x22;) {
      redefinition = this.strict &#x26;&#x26; other.init || other.get || other.set
    } else {
      redefinition = other.init || other[kind]
    }
    if (redefinition)
      this.raiseRecoverable(key.start, &#x22;Redefinition of property&#x22;)
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    }
  }
  other[kind] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this$1.type !== tt.colon &#x26;&#x26; !this$1.canInsertSemicolon()) {
    isAsync = true
    this$1.parsePropertyName(prop, refDestructuringErrors)
  } else {
    isAsync = false
  }
  this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)
  this$1.<span class="apidocCodeKeywordSpan">checkPropClash</span>(prop, propHash)
  node.properties.push(this$1.finishNode(prop, &#x22;Property&#x22;))
}
return this.finishNode(node, isPattern ? &#x22;ObjectPattern&#x22; : &#x22;ObjectExpression&#x22;)
}

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
if ((isGenerator || isAsync) &#x26;&#x26; this.type === tt.colon)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkVariableExport" id="apidoc.element.acorn.Parser.prototype.checkVariableExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkVariableExport
        <span class="apidocSignatureSpan">(exports, decls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkVariableExport = function (exports, decls) {
  var this$1 = this;

  if (!exports) return
  for (var i = 0; i &#x3c; decls.length; i++)
    this$1.checkPatternExport(exports, decls[i].id)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return this.finishNode(node, &#x22;ExportDefaultDeclaration&#x22;)
}
// export var|const|let|function|class ...
if (this.shouldParseExportStatement()) {
  node.declaration = this.parseStatement(true)
  if (node.declaration.type === &#x22;VariableDeclaration&#x22;)
    this.<span class="apidocCodeKeywordSpan">checkVariableExport</span>(exports, node.declaration.declarations)
  else
    this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)
  node.specifiers = []
  node.source = null
} else { // export { x, y as z } [from &#x27;...&#x27;]
  node.declaration = null
  node.specifiers = this.parseExportSpecifiers(exports)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkYieldAwaitInDefaultParams" id="apidoc.element.acorn.Parser.prototype.checkYieldAwaitInDefaultParams">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkYieldAwaitInDefaultParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos &#x26;&#x26; (!this.awaitPos || this.yieldPos &#x3c; this.awaitPos))
    this.raise(this.yieldPos, &#x22;Yield expression cannot be a default value&#x22;)
  if (this.awaitPos)
    this.raise(this.awaitPos, &#x22;Await expression cannot be a default value&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.inFunction = oldInFunc
return this.finishNode(node, isStatement ? &#x22;FunctionDeclaration&#x22; : &#x22;FunctionExpression&#x22;)
}

pp$1.parseFunctionParams = function(node) {
this.expect(tt.parenL)
node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion &#x3e;= 8, true)
this.<span class="apidocCodeKeywordSpan">checkYieldAwaitInDefaultParams</span>()
}

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
var this$1 = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.curContext" id="apidoc.element.acorn.Parser.prototype.curContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">curContext = function () {
  return this.context[this.context.length - 1]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$7.initialContext = function() {
return [types.b_stat]
}

pp$7.braceIsBlock = function(prevType) {
if (prevType === tt.colon) {
  var parent = this.<span class="apidocCodeKeywordSpan">curContext</span>()
  if (parent === types.b_stat || parent === types.b_expr)
    return !parent.isExpr
}
if (prevType === tt._return)
  return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR || prevType == tt.arrow)
  return true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.curPosition" id="apidoc.element.acorn.Parser.prototype.curPosition">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curPosition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">curPosition = function () {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.type = tt.eof
// For tokens that include more information than their type, the value
this.value = null
// Its start and end offset
this.start = this.end = this.pos
// And, if locations are used, the {line, column} object
// corresponding to those offsets
this.startLoc = this.endLoc = this.<span class="apidocCodeKeywordSpan">curPosition</span>()

// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null
this.lastTokStart = this.lastTokEnd = this.pos

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.declareLexicalName" id="apidoc.element.acorn.Parser.prototype.declareLexicalName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareLexicalName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      bindingType !== &#x22;var&#x22; &#x26;&#x26; !this.canDeclareLexicalName(expr.name)
    ) {
      this.raiseRecoverable(expr.start, (&#x22;Identifier &#x27;&#x22; + (expr.name) + &#x22;&#x27; has already been declared&#x22
;))
    }
    if (bindingType === &#x22;var&#x22;) {
      this.declareVarName(expr.name)
    } else {
      this.<span class="apidocCodeKeywordSpan">declareLexicalName</span>(expr.name)
    }
  }
  break

case &#x22;MemberExpression&#x22;:
  if (bindingType) this.raiseRecoverable(expr.start, (bindingType ? &#x22;Binding&#x22; : &#x22;Assigning to&#x22;) + &#x22; member
 expression&#x22;)
  break
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.declareVarName" id="apidoc.element.acorn.Parser.prototype.declareVarName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareVarName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (
      bindingType === &#x22;var&#x22; &#x26;&#x26; !this.canDeclareVarName(expr.name) ||
      bindingType !== &#x22;var&#x22; &#x26;&#x26; !this.canDeclareLexicalName(expr.name)
    ) {
      this.raiseRecoverable(expr.start, (&#x22;Identifier &#x27;&#x22; + (expr.name) + &#x22;&#x27; has already been declared&#x22
;))
    }
    if (bindingType === &#x22;var&#x22;) {
      this.<span class="apidocCodeKeywordSpan">declareVarName</span>(expr.name)
    } else {
      this.declareLexicalName(expr.name)
    }
  }
  break

case &#x22;MemberExpression&#x22;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.eat" id="apidoc.element.acorn.Parser.prototype.eat">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eat
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eat = function (type) {
  if (this.type === type) {
    this.next()
    return true
  } else {
    return false
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.isContextual = function(name) {
  return this.type === tt.name &#x26;&#x26; this.value === name
}

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  return this.value === name &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">eat</span>(tt.name)
}

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) this.unexpected()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.eatContextual" id="apidoc.element.acorn.Parser.prototype.eatContextual">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eatContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eatContextual = function (name) {
  return this.value === name &#x26;&#x26; this.eat(tt.name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.eatContextual = function(name) {
return this.value === name &#x26;&#x26; this.eat(tt.name)
}

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
if (!this.<span class="apidocCodeKeywordSpan">eatContextual</span>(name)) this.unexpected()
}

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
return this.type === tt.eof ||
  this.type === tt.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.enterFunctionScope" id="apidoc.element.acorn.Parser.prototype.enterFunctionScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterFunctionScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enterFunctionScope = function () {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function
 scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current
 function scope)
  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &#x26;&#x26; options.allowHashBang &#x26;&#x26; this.input.slice(0, 2) === &#x22;#!&#x22;)
    this.skipLineComment(2)

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = []
  this.<span class="apidocCodeKeywordSpan">enterFunctionScope</span>()
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };

Parser.prototype.extend = function extend (name, f) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.enterLexicalScope" id="apidoc.element.acorn.Parser.prototype.enterLexicalScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterLexicalScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1]
  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}}

  this.scopeStack.push(childScope)
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
this.next()
this.labels.push(loopLabel)
this.<span class="apidocCodeKeywordSpan">enterLexicalScope</span>()
this.expect(tt.parenL)
if (this.type === tt.semi) return this.parseFor(node, null)
var isLet = this.isLet()
if (this.type === tt._var || this.type === tt._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &#x22;let&#x22; : this.value
  this.next()
  this.parseVar(init$1, true, kind)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.exitFunctionScope" id="apidoc.element.acorn.Parser.prototype.exitFunctionScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitFunctionScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitFunctionScope = function () {
  this.scopeStack.pop()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &#x26;&#x26; !useStrict &#x26;&#x26; !isArrowFunction &#x26;&#x26; this.isSimpleParamList(
node.params))
    node.body = this.parseBlock(false)
    node.expression = false
    this.labels = oldLabels
  }
  this.<span class="apidocCodeKeywordSpan">exitFunctionScope</span>()

  if (this.strict &#x26;&#x26; node.id) {
    // Ensure the function name isn&#x27;t a forbidden identifier in strict mode, e.g. &#x27;eval&#x27;
    this.checkLVal(node.id, &#x22;none&#x22;)
  }
  this.strict = oldStrict
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.exitLexicalScope" id="apidoc.element.acorn.Parser.prototype.exitLexicalScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitLexicalScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitLexicalScope = function () {
  var childScope = this.scopeStack.pop()
  var parentScope = this.scopeStack[this.scopeStack.length - 1]

  assign(parentScope.childVar, childScope.var, childScope.childVar)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
      this$1.expect(tt.colon)
    } else {
      if (!cur) this$1.unexpected()
      cur.consequent.push(this$1.parseStatement(true))
    }
  }
  this.<span class="apidocCodeKeywordSpan">exitLexicalScope</span>()
  if (cur) this.finishNode(cur, &#x22;SwitchCase&#x22;)
  this.next() // Closing brace
  this.labels.pop()
  return this.finishNode(node, &#x22;SwitchStatement&#x22;)
}

pp$1.parseThrowStatement = function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.expect" id="apidoc.element.acorn.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expect = function (type) {
  this.eat(type) || this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

pp$1.parseDoStatement = function(node) {
  this.next()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  this.<span class="apidocCodeKeywordSpan">expect</span>(tt._while)
  node.test = this.parseParenExpression()
  if (this.options.ecmaVersion &#x3e;= 6)
    this.eat(tt.semi)
  else
    this.semicolon()
  return this.finishNode(node, &#x22;DoWhileStatement&#x22;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.expectContextual" id="apidoc.element.acorn.Parser.prototype.expectContextual">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expectContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$1.parseExport = function(node, exports) {
var this$1 = this;

this.next()
// export * from &#x27;...&#x27;
if (this.eat(tt.star)) {
  this.<span class="apidocCodeKeywordSpan">expectContextual</span>(&#x22;from&#x22;)
  node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  this.semicolon()
  return this.finishNode(node, &#x22;ExportAllDeclaration&#x22;)
}
if (this.eat(tt._default)) { // export default ...
  this.checkExport(exports, &#x22;default&#x22;, this.lastTokStart)
  var isAsync
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.extend" id="apidoc.element.acorn.Parser.prototype.extend">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>extend
        <span class="apidocSignatureSpan">(name, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(name, f) {
  this[name] = f(this[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options). After the parser object has been created, the initialization
functions for the chosen plugins are called with `(parser,
configValue)` arguments. They are expected to use the `parser.extend`
method to extend parser methods. For example, the `readToken` method
could be extended like this:

```javascript
parser.<span class="apidocCodeKeywordSpan">extend</span>(&#x22;readToken&#x22;, function(nextMethod) {
  return function(code) {
    console.log(&#x22;Reading a token!&#x22;)
    return nextMethod.call(this, code)
  }
})
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishNode" id="apidoc.element.acorn.Parser.prototype.finishNode">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var stmt = this$1.parseStatement(true, true, exports)
  node.body.push(stmt)
}
this.next()
if (this.options.ecmaVersion &#x3e;= 6) {
  node.sourceType = this.options.sourceType
}
return this.<span class="apidocCodeKeywordSpan">finishNode</span>(node, &#x22;Program&#x22;)
}

var loopLabel = {kind: &#x22;loop&#x22;};
var switchLabel = {kind: &#x22;switch&#x22;};
pp$1.isLet = function() {
if (this.type !== tt.name || this.options.ecmaVersion &#x3c; 6 || this.value != &#x22;let&#x22;) return false
skipWhiteSpace.lastIndex = this.pos
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishNodeAt" id="apidoc.element.acorn.Parser.prototype.finishNodeAt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNodeAt
        <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.checkExpressionErrors(refDestructuringErrors, true)
  this.yieldPos = oldYieldPos || this.yieldPos
  this.awaitPos = oldAwaitPos || this.awaitPos

  if (exprList.length &#x3e; 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc)
    val.expressions = exprList
    this.<span class="apidocCodeKeywordSpan">finishNodeAt</span>(val, &#x22;SequenceExpression&#x22;, innerEndPos, innerEndLoc)
  } else {
    val = exprList[0]
  }
} else {
  val = this.parseParenExpression()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishOp" id="apidoc.element.acorn.Parser.prototype.finishOp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishOp
        <span class="apidocSignatureSpan">(type, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size)
  this.pos += size
  return this.finishToken(type, str)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.finishToken(tt.dot)
}
}

pp$8.readToken_slash = function() { // &#x27;/&#x27;
var next = this.input.charCodeAt(this.pos + 1)
if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
if (next === 61) return this.<span class="apidocCodeKeywordSpan">finishOp</span>(tt.assign, 2)
return this.finishOp(tt.slash, 1)
}

pp$8.readToken_mult_modulo_exp = function(code) { // &#x27;%*&#x27;
var next = this.input.charCodeAt(this.pos + 1)
var size = 1
var tokentype = code === 42 ? tt.star : tt.modulo
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishToken" id="apidoc.element.acorn.Parser.prototype.finishToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishToken
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishToken = function (type, val) {
  this.end = this.pos
  if (this.options.locations) this.endLoc = this.curPosition()
  var prevType = this.type
  this.type = type
  this.value = val

  this.updateContext(prevType)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$8.nextToken = function() {
var curContext = this.curContext()
if (!curContext || !curContext.preserveSpace) this.skipSpace()

this.start = this.pos
if (this.options.locations) this.startLoc = this.curPosition()
if (this.pos &#x3e;= this.input.length) return this.<span class="apidocCodeKeywordSpan">finishToken</span>(tt.eof)

if (curContext.override) return curContext.override(this)
else this.readToken(this.fullCharCodeAtPos())
}

pp$8.readToken = function(code) {
// Identifier or keyword. &#x27;\uXXXX&#x27; sequences are allowed in
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.fullCharCodeAtPos" id="apidoc.element.acorn.Parser.prototype.fullCharCodeAtPos">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>fullCharCodeAtPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos)
  if (code &#x3c;= 0xd7ff || code &#x3e;= 0xe000) return code
  var next = this.input.charCodeAt(this.pos + 1)
  return (code &#x3c;&#x3c; 10) + next - 0x35fdc00
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!curContext || !curContext.preserveSpace) this.skipSpace()

this.start = this.pos
if (this.options.locations) this.startLoc = this.curPosition()
if (this.pos &#x3e;= this.input.length) return this.finishToken(tt.eof)

if (curContext.override) return curContext.override(this)
else this.readToken(this.<span class="apidocCodeKeywordSpan">fullCharCodeAtPos</span>())
}

pp$8.readToken = function(code) {
// Identifier or keyword. &#x27;\uXXXX&#x27; sequences are allowed in
// identifiers, so &#x27;\&#x27; also dispatches to that.
if (isIdentifierStart(code, this.options.ecmaVersion &#x3e;= 6) || code === 92 /* &#x27;\&#x27; */)
  return this.readWord()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.getToken" id="apidoc.element.acorn.Parser.prototype.getToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getToken = function () {
  this.next()
  return new Token(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- **locations**: When `true`, each node has a `loc` object attached
  with `start` and `end` subobjects, each of which contains the
  one-based line and zero-based column numbers in `{line, column}`
  form. Default is `false`.

- **onToken**: If a function is passed for this option, each found
  token will be passed in same format as tokens returned from
  `tokenizer().<span class="apidocCodeKeywordSpan">getToken</span>()`.

  If array is passed, each found token is pushed to it.

  Note that you are not allowed to call the parser from the
  callback—that will corrupt its internal state.

- **onComment**: If a function is passed for this option, whenever a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.getTokenFromCode" id="apidoc.element.acorn.Parser.prototype.getTokenFromCode">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getTokenFromCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
  case 46: // &#x27;.&#x27;
    return this.readToken_dot()

    // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(tt.parenL)
  case 41: ++this.pos; return this.finishToken(tt.parenR)
  case 59: ++this.pos; return this.finishToken(tt.semi)
  case 44: ++this.pos; return this.finishToken(tt.comma)
  case 91: ++this.pos; return this.finishToken(tt.bracketL)
  case 93: ++this.pos; return this.finishToken(tt.bracketR)
  case 123: ++this.pos; return this.finishToken(tt.braceL)
  case 125: ++this.pos; return this.finishToken(tt.braceR)
  case 58: ++this.pos; return this.finishToken(tt.colon)
  case 63: ++this.pos; return this.finishToken(tt.question)

  case 96: // &#x27;`&#x27;
    if (this.options.ecmaVersion &#x3c; 6) break
    ++this.pos
    return this.finishToken(tt.backQuote)

  case 48: // &#x27;0&#x27;
    var next = this.input.charCodeAt(this.pos + 1)
    if (next === 120 || next === 88) return this.readRadixNumber(16) // &#x27;0x&#x27;, &#x27;0X&#x27; - hex number
    if (this.options.ecmaVersion &#x3e;= 6) {
      if (next === 111 || next === 79) return this.readRadixNumber(8) // &#x27;0o&#x27;, &#x27;0O&#x27; - octal number
      if (next === 98 || next === 66) return this.readRadixNumber(2) // &#x27;0b&#x27;, &#x27;0B&#x27; - binary number
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

    // Quotes produce strings.
  case 34: case 39: // &#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;
    return this.readString(code)

    // Operators are parsed inline in tiny state machines. &#x27;=&#x27; (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

  case 47: // &#x27;/&#x27;
    return this.readToken_slash()

  case 37: case 42: // &#x27;%*&#x27;
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // &#x27;|&#x26;&#x27;
    return this.readToken_pipe_amp(code)

  case 94: // &#x27;^&#x27;
    return this.readToken_caret()

  case 43: case 45: // &#x27;+-&#x27;
    return this.readToken_plus_min(code)

  case 60: case 62: // &#x27;&#x3c;&#x3e;&#x27;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &#x27;=!&#x27;
    return this.readToken_eq_excl(code)

  case 126: // &#x27;~&#x27;
    return this.finishOp(tt.prefix, 1)
  }

  this.raise(this.pos, &#x22;Unexpected character &#x27;&#x22; + codePointToString(code) + &#x22;&#x27;&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$8.readToken = function(code) {
// Identifier or keyword. &#x27;\uXXXX&#x27; sequences are allowed in
// identifiers, so &#x27;\&#x27; also dispatches to that.
if (isIdentifierStart(code, this.options.ecmaVersion &#x3e;= 6) || code === 92 /* &#x27;\&#x27; */)
  return this.readWord()

return this.<span class="apidocCodeKeywordSpan">getTokenFromCode</span>(code)
}

pp$8.fullCharCodeAtPos = function() {
var code = this.input.charCodeAt(this.pos)
if (code &#x3c;= 0xd7ff || code &#x3e;= 0xe000) return code
var next = this.input.charCodeAt(this.pos + 1)
return (code &#x3c;&#x3c; 10) + next - 0x35fdc00
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.inGeneratorContext" id="apidoc.element.acorn.Parser.prototype.inGeneratorContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>inGeneratorContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inGeneratorContext = function () {
  var this$1 = this;

  for (var i = this.context.length - 1; i &#x3e;= 0; i--)
    if (this$1.context[i].generator) return true
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.exprAllowed = true
}

tt.name.updateContext = function(prevType) {
  var allowed = false
  if (this.options.ecmaVersion &#x3e;= 6) {
    if (this.value == &#x22;of&#x22; &#x26;&#x26; !this.exprAllowed ||
        this.value == &#x22;yield&#x22; &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">inGeneratorContext</span>())
      allowed = true
  }
  this.exprAllowed = allowed
}

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.initFunction" id="apidoc.element.acorn.Parser.prototype.initFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initFunction = function (node) {
  node.id = null
  if (this.options.ecmaVersion &#x3e;= 6) {
    node.generator = false
    node.expression = false
  }
  if (this.options.ecmaVersion &#x3e;= 8)
    node.async = false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.checkLVal(decl.id, kind, false)
}

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
this.<span class="apidocCodeKeywordSpan">initFunction</span>(node)
if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; !isAsync)
  node.generator = this.eat(tt.star)
if (this.options.ecmaVersion &#x3e;= 8)
  node.async = !!isAsync

if (isStatement) {
  node.id = isStatement === &#x22;nullableID&#x22; &#x26;&#x26; this.type != tt.name ? null : this.parseIdent()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.initialContext" id="apidoc.element.acorn.Parser.prototype.initialContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initialContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialContext = function () {
  return [types.b_stat]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Position information for the previous token
this.lastTokEndLoc = this.lastTokStartLoc = null
this.lastTokStart = this.lastTokEnd = this.pos

// The context stack is used to superficially track syntactic
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.<span class="apidocCodeKeywordSpan">initialContext</span>()
this.exprAllowed = true

// Figure out if it&#x27;s a module code.
this.inModule = options.sourceType === &#x22;module&#x22;
this.strict = this.inModule || this.strictDirective(this.pos)

// Used to signify the start of a potential arrow function
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.insertSemicolon" id="apidoc.element.acorn.Parser.prototype.insertSemicolon">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>insertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
if (!this.eat(tt.semi) &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">insertSemicolon</span>()) this.unexpected()
}

pp.afterTrailingComma = function(tokType, notNext) {
if (this.type == tokType) {
  if (this.options.onTrailingComma)
    this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
  if (!notNext)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isAsyncFunction" id="apidoc.element.acorn.Parser.prototype.isAsyncFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isAsyncFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAsyncFunction = function () {
  if (this.type !== tt.name || this.options.ecmaVersion &#x3c; 8 || this.value != &#x22;async&#x22;)
    return false

  skipWhiteSpace.lastIndex = this.pos
  var skip = skipWhiteSpace.exec(this.input)
  var next = this.pos + skip[0].length
  return !lineBreak.test(this.input.slice(this.pos, next)) &#x26;&#x26;
    this.input.slice(next, next + 8) === &#x22;function&#x22; &#x26;&#x26;
    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// If the statement does not start with a statement keyword or a
// brace, it&#x27;s an ExpressionStatement or LabeledStatement. We
// simply start parsing an expression, and afterwards, if the
// next token is a colon and the expression was a simple
// Identifier node, we switch to interpreting it as a label.
  default:
if (this.<span class="apidocCodeKeywordSpan">isAsyncFunction</span>() &#x26;&#x26; declaration) {
  this.next()
  return this.parseFunctionStatement(node, true)
}

var maybeName = this.value, expr = this.parseExpression()
if (starttype === tt.name &#x26;&#x26; expr.type === &#x22;Identifier&#x22; &#x26;&#x26; this.eat(tt.colon))
  return this.parseLabeledStatement(node, maybeName, expr)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isContextual" id="apidoc.element.acorn.Parser.prototype.isContextual">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isContextual = function (name) {
  return this.type === tt.name &#x26;&#x26; this.value === name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.type === tt.semi) return this.parseFor(node, null)
var isLet = this.isLet()
if (this.type === tt._var || this.type === tt._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &#x22;let&#x22; : this.value
  this.next()
  this.parseVar(init$1, true, kind)
  this.finishNode(init$1, &#x22;VariableDeclaration&#x22;)
  if ((this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">isContextual
</span>(&#x22;of&#x22;))) &#x26;&#x26; init$1.declarations.length === 1 &#x26;&#x26;
      !(kind !== &#x22;var&#x22; &#x26;&#x26; init$1.declarations[0].init))
    return this.parseForIn(node, init$1)
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors
var init = this.parseExpression(true, refDestructuringErrors)
if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isFunction" id="apidoc.element.acorn.Parser.prototype.isFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFunction = function () {
  return this.type === tt._function || this.isAsyncFunction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this.type === tt._function || this.isAsyncFunction()
}

pp$1.parseIfStatement = function(node) {
this.next()
node.test = this.parseParenExpression()
// allow function declarations in branches, but only in non-strict mode
node.consequent = this.parseStatement(!this.strict &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">isFunction</span>())
node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict &#x26;&#x26; this.isFunction()) : null
return this.finishNode(node, &#x22;IfStatement&#x22;)
}

pp$1.parseReturnStatement = function(node) {
if (!this.inFunction &#x26;&#x26; !this.options.allowReturnOutsideFunction)
  this.raise(this.start, &#x22;&#x27;return&#x27; outside of function&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isKeyword" id="apidoc.element.acorn.Parser.prototype.isKeyword">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isKeyword
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isKeyword(word) { return this.keywords.test(word) }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var skip = skipWhiteSpace.exec(this.input)
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)
  if (nextCh === 91 || nextCh == 123) return true // &#x27;{&#x27; and &#x27;[&#x27;
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) ++pos
    var ident = this.input.slice(next, pos)
    if (!this.<span class="apidocCodeKeywordSpan">isKeyword</span>(ident)) return true
  }
  return false
}

// check &#x27;async [no LineTerminator here] function&#x27;
// - &#x27;async /*foo*/ function&#x27; is OK.
// - &#x27;async /*\n*/ function&#x27; is invalid.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isLet" id="apidoc.element.acorn.Parser.prototype.isLet">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isLet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLet = function () {
  if (this.type !== tt.name || this.options.ecmaVersion &#x3c; 6 || this.value != &#x22;let&#x22;) return false
  skipWhiteSpace.lastIndex = this.pos
  var skip = skipWhiteSpace.exec(this.input)
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)
  if (nextCh === 91 || nextCh == 123) return true // &#x27;{&#x27; and &#x27;[&#x27;
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) ++pos
    var ident = this.input.slice(next, pos)
    if (!this.isKeyword(ident)) return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(declaration, topLevel, exports) {
var starttype = this.type, node = this.startNode(), kind

if (this.<span class="apidocCodeKeywordSpan">isLet</span>()) {
  starttype = tt._var
  kind = &#x22;let&#x22;
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isReservedWord" id="apidoc.element.acorn.Parser.prototype.isReservedWord">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isReservedWord
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isReservedWord(word) { return this.reservedWords.test(word) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isSimpleAssignTarget" id="apidoc.element.acorn.Parser.prototype.isSimpleAssignTarget">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleAssignTarget
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAssignTarget = function (expr) {
  if (expr.type === &#x22;ParenthesizedExpression&#x22;)
    return this.isSimpleAssignTarget(expr.expression)
  return expr.type === &#x22;Identifier&#x22; || expr.type === &#x22;MemberExpression&#x22;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.raise(this.yieldPos, &#x22;Yield expression cannot be a default value&#x22;)
  if (this.awaitPos)
    this.raise(this.awaitPos, &#x22;Await expression cannot be a default value&#x22;)
}

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === &#x22;ParenthesizedExpression&#x22;)
    return this.<span class="apidocCodeKeywordSpan">isSimpleAssignTarget</span>(expr.expression)
  return expr.type === &#x22;Identifier&#x22; || expr.type === &#x22;MemberExpression&#x22;
}

var pp$1 = Parser.prototype

// ### Statement parsing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isSimpleParamList" id="apidoc.element.acorn.Parser.prototype.isSimpleParamList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleParamList
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleParamList = function (params) {
  for (var i = 0; i &#x3c; params.length; i++)
    if (params[i].type !== &#x22;Identifier&#x22;) return false
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var oldStrict = this.strict, useStrict = false

if (isExpression) {
  node.body = this.parseMaybeAssign()
  node.expression = true
  this.checkParams(node, false)
} else {
  var nonSimple = this.options.ecmaVersion &#x3e;= 7 &#x26;&#x26; !this.<span class="apidocCodeKeywordSpan">isSimpleParamList</span
>(node.params)
  if (!oldStrict || nonSimple) {
    useStrict = this.strictDirective(this.end)
    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (useStrict &#x26;&#x26; nonSimple)
      this.raiseRecoverable(node.start, &#x22;Illegal &#x27;use strict&#x27; directive in function with non-simple parameter list
&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.loadPlugins" id="apidoc.element.acorn.Parser.prototype.loadPlugins">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>loadPlugins
        <span class="apidocSignatureSpan">(pluginConfigs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadPlugins(pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name]
    if (!plugin) throw new Error(&#x22;Plugin &#x27;&#x22; + name + &#x22;&#x27; not found&#x22;)
    plugin(this$1, pluginConfigs[name])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Used to signal to callers of `readWord1` whether the word
// contained any escape sequences. This is needed because words with
// escape sequences must not be interpreted as keywords.
this.containsEsc = false

// Load plugins
this.<span class="apidocCodeKeywordSpan">loadPlugins</span>(options.plugins)

// Set up token state

// The current position of the tokenizer in the input.
if (startPos) {
  this.pos = startPos
  this.lineStart = this.input.lastIndexOf(&#x22;\n&#x22;, startPos - 1) + 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.next" id="apidoc.element.acorn.Parser.prototype.next">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
  if (this.options.onToken)
    this.options.onToken(new Token(this))

  this.lastTokEnd = this.end
  this.lastTokStart = this.start
  this.lastTokEndLoc = this.endLoc
  this.lastTokStartLoc = this.startLoc
  this.nextToken()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.<span class="apidocCodeKeywordSpan">next</span>()
    return true
  } else {
    return false
  }
}

// Tests whether parsed token is a contextual keyword.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.nextToken" id="apidoc.element.acorn.Parser.prototype.nextToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextToken = function () {
  var curContext = this.curContext()
  if (!curContext || !curContext.preserveSpace) this.skipSpace()

  this.start = this.pos
  if (this.options.locations) this.startLoc = this.curPosition()
  if (this.pos &#x3e;= this.input.length) return this.finishToken(tt.eof)

  if (curContext.override) return curContext.override(this)
  else this.readToken(this.fullCharCodeAtPos())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!plugin) throw new Error(&#x22;Plugin &#x27;&#x22; + name + &#x22;&#x27; not found&#x22;)
    plugin(this$1, pluginConfigs[name])
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode()
  this.<span class="apidocCodeKeywordSpan">nextToken</span>()
  return this.parseTopLevel(node)
};

var pp = Parser.prototype

// ## Parser utilities
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parse" id="apidoc.element.acorn.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse() {
  var node = this.options.program || this.startNode()
  this.nextToken()
  return this.parseTopLevel(node)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Escodegen supports generating comments from AST, attached in
Esprima-specific format. In order to simulate same format in
Acorn, consider following example:

```javascript
var comments = [], tokens = [];

var ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>(&#x27;var x = 42; // answer&#x27;, {
	// collect ranges for each node
	ranges: true,
	// collect comments in Esprima&#x27;s format
	onComment: comments,
	// collect token ranges
	onToken: tokens
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseArrowExpression" id="apidoc.element.acorn.Parser.prototype.parseArrowExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseArrowExpression
        <span class="apidocSignatureSpan">(node, params, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArrowExpression = function (node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction

  this.enterFunctionScope()
  this.initFunction(node)
  if (this.options.ecmaVersion &#x3e;= 8)
    node.async = !!isAsync

  this.inGenerator = false
  this.inAsync = node.async
  this.yieldPos = 0
  this.awaitPos = 0
  this.inFunction = true

  node.params = this.toAssignableList(params, true)
  this.parseFunctionBody(node, true)

  this.inGenerator = oldInGen
  this.inAsync = oldInAsync
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, &#x22;ArrowFunctionExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this$1.awaitPos = 0
var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion &#x3e;= 8, false, refDestructuringErrors)
if (maybeAsyncArrow &#x26;&#x26; !this$1.canInsertSemicolon() &#x26;&#x26; this$1.eat(tt.arrow)) {
  this$1.checkPatternErrors(refDestructuringErrors, false)
  this$1.checkYieldAwaitInDefaultParams()
  this$1.yieldPos = oldYieldPos
  this$1.awaitPos = oldAwaitPos
  return this$1.<span class="apidocCodeKeywordSpan">parseArrowExpression</span>(this$1.startNodeAt(startPos, startLoc), exprList
, true)
}
this$1.checkExpressionErrors(refDestructuringErrors, true)
this$1.yieldPos = oldYieldPos || this$1.yieldPos
this$1.awaitPos = oldAwaitPos || this$1.awaitPos
var node$1 = this$1.startNodeAt(startPos, startLoc)
node$1.callee = base
node$1.arguments = exprList
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseAwait" id="apidoc.element.acorn.Parser.prototype.parseAwait">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseAwait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseAwait = function () {
  if (!this.awaitPos) this.awaitPos = this.start

  var node = this.startNode()
  this.next()
  node.argument = this.parseMaybeUnary(null, true)
  return this.finishNode(node, &#x22;AwaitExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
var this$1 = this;

var startPos = this.start, startLoc = this.startLoc, expr
if (this.inAsync &#x26;&#x26; this.isContextual(&#x22;await&#x22;)) {
  expr = this.<span class="apidocCodeKeywordSpan">parseAwait</span>(refDestructuringErrors)
  sawUnary = true
} else if (this.type.prefix) {
  var node = this.startNode(), update = this.type === tt.incDec
  node.operator = this.value
  node.prefix = true
  this.next()
  node.argument = this.parseMaybeUnary(null, true)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBindingAtom" id="apidoc.element.acorn.Parser.prototype.parseBindingAtom">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingAtom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingAtom = function () {
  if (this.options.ecmaVersion &#x3c; 6) return this.parseIdent()
  switch (this.type) {
  case tt.name:
    return this.parseIdent()

  case tt.bracketL:
    var node = this.startNode()
    this.next()
    node.elements = this.parseBindingList(tt.bracketR, true, true)
    return this.finishNode(node, &#x22;ArrayPattern&#x22;)

  case tt.braceL:
    return this.parseObj(true)

  default:
    this.unexpected()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.next()
node.block = this.parseBlock()
node.handler = null
if (this.type === tt._catch) {
  var clause = this.startNode()
  this.next()
  this.expect(tt.parenL)
  clause.param = this.<span class="apidocCodeKeywordSpan">parseBindingAtom</span>()
  this.enterLexicalScope()
  this.checkLVal(clause.param, &#x22;let&#x22;)
  this.expect(tt.parenR)
  clause.body = this.parseBlock(false)
  this.exitLexicalScope()
  node.handler = this.finishNode(clause, &#x22;CatchClause&#x22;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBindingList" id="apidoc.element.acorn.Parser.prototype.parseBindingList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingList
        <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma, allowNonIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var this$1 = this;

  var elts = [], first = true
  while (!this.eat(close)) {
    if (first) first = false
    else this$1.expect(tt.comma)
    if (allowEmpty &#x26;&#x26; this$1.type === tt.comma) {
      elts.push(null)
    } else if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === tt.ellipsis) {
      var rest = this$1.parseRest(allowNonIdent)
      this$1.parseBindingListItem(rest)
      elts.push(rest)
      if (this$1.type === tt.comma) this$1.raise(this$1.start, &#x22;Comma is not permitted after the rest element&#x22;)
      this$1.expect(close)
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
      this$1.parseBindingListItem(elem)
      elts.push(elem)
    }
  }
  return elts
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, isStatement ? &#x22;FunctionDeclaration&#x22; : &#x22;FunctionExpression&#x22;)
}

pp$1.parseFunctionParams = function(node) {
  this.expect(tt.parenL)
  node.params = this.<span class="apidocCodeKeywordSpan">parseBindingList</span>(tt.parenR, false, this.options.ecmaVersion &#x3e
;= 8, true)
  this.checkYieldAwaitInDefaultParams()
}

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBindingListItem" id="apidoc.element.acorn.Parser.prototype.parseBindingListItem">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingListItem
        <span class="apidocSignatureSpan">(param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingListItem = function (param) {
  return param
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else this$1.expect(tt.comma)
if (allowEmpty &#x26;&#x26; this$1.type === tt.comma) {
  elts.push(null)
} else if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(close)) {
  break
} else if (this$1.type === tt.ellipsis) {
  var rest = this$1.parseRest(allowNonIdent)
  this$1.<span class="apidocCodeKeywordSpan">parseBindingListItem</span>(rest)
  elts.push(rest)
  if (this$1.type === tt.comma) this$1.raise(this$1.start, &#x22;Comma is not permitted after the rest element&#x22;)
  this$1.expect(close)
  break
} else {
  var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
  this$1.parseBindingListItem(elem)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBlock" id="apidoc.element.acorn.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">(createNewLexicalScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlock = function (createNewLexicalScope) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;

  var node = this.startNode()
  node.body = []
  this.expect(tt.braceL)
  if (createNewLexicalScope) {
    this.enterLexicalScope()
  }
  while (!this.eat(tt.braceR)) {
    var stmt = this$1.parseStatement(true)
    node.body.push(stmt)
  }
  if (createNewLexicalScope) {
    this.exitLexicalScope()
  }
  return this.finishNode(node, &#x22;BlockStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.parseWhileStatement(node)
case tt._with: return this.parseWithStatement(node)
case tt.braceL: return this.<span class="apidocCodeKeywordSpan">parseBlock</span>()
case tt.semi: return this.parseEmptyStatement(node)
case tt._export:
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level&#x22;)
    if (!this.inModule)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBreakContinueStatement" id="apidoc.element.acorn.Parser.prototype.parseBreakContinueStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBreakContinueStatement
        <span class="apidocSignatureSpan">(node, keyword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBreakContinueStatement = function (node, keyword) {
  var this$1 = this;

  var isBreak = keyword == &#x22;break&#x22;
  this.next()
  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
  else if (this.type !== tt.name) this.unexpected()
  else {
    node.label = this.parseIdent()
    this.semicolon()
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0
  for (; i &#x3c; this.labels.length; ++i) {
    var lab = this$1.labels[i]
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &#x26;&#x26; (isBreak || lab.kind === &#x22;loop&#x22;)) break
      if (node.label &#x26;&#x26; isBreak) break
    }
  }
  if (i === this.labels.length) this.raise(node.start, &#x22;Unsyntactic &#x22; + keyword)
  return this.finishNode(node, isBreak ? &#x22;BreakStatement&#x22; : &#x22;ContinueStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case tt._break: case tt._continue: return this.<span class="apidocCodeKeywordSpan">parseBreakContinueStatement</span>(node, starttype
.keyword)
case tt._debugger: return this.parseDebuggerStatement(node)
case tt._do: return this.parseDoStatement(node)
case tt._for: return this.parseForStatement(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClass" id="apidoc.element.acorn.Parser.prototype.parseClass">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClass
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClass = function (node, isStatement) {
  var this$1 = this;

  this.next()

  this.parseClassId(node, isStatement)
  this.parseClassSuper(node)
  var classBody = this.startNode()
  var hadConstructor = false
  classBody.body = []
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (this$1.eat(tt.semi)) continue
    var method = this$1.startNode()
    var isGenerator = this$1.eat(tt.star)
    var isAsync = false
    var isMaybeStatic = this$1.type === tt.name &#x26;&#x26; this$1.value === &#x22;static&#x22;
    this$1.parsePropertyName(method)
    method.static = isMaybeStatic &#x26;&#x26; this$1.type !== tt.parenL
    if (method.static) {
      if (isGenerator) this$1.unexpected()
      isGenerator = this$1.eat(tt.star)
      this$1.parsePropertyName(method)
    }
    if (this$1.options.ecmaVersion &#x3e;= 8 &#x26;&#x26; !isGenerator &#x26;&#x26; !method.computed &#x26;&#x26;
        method.key.type === &#x22;Identifier&#x22; &#x26;&#x26; method.key.name === &#x22;async&#x22; &#x26;&#x26; this$1.type !== tt.parenL &#x26;&#x26;
        !this$1.canInsertSemicolon()) {
      isAsync = true
      this$1.parsePropertyName(method)
    }
    method.kind = &#x22;method&#x22;
    var isGetSet = false
    if (!method.computed) {
      var key = method.key;
      if (!isGenerator &#x26;&#x26; !isAsync &#x26;&#x26; key.type === &#x22;Identifier&#x22; &#x26;&#x26; this$1.type !== tt.parenL &#x26;&#x26; (key.name === &#x22;get&#x22; || key.name === &#x22;
set&#x22;)) {
        isGetSet = true
        method.kind = key.name
        key = this$1.parsePropertyName(method)
      }
      if (!method.static &#x26;&#x26; (key.type === &#x22;Identifier&#x22; &#x26;&#x26; key.name === &#x22;constructor&#x22; ||
          key.type === &#x22;Literal&#x22; &#x26;&#x26; key.value === &#x22;constructor&#x22;)) {
        if (hadConstructor) this$1.raise(key.start, &#x22;Duplicate constructor in the same class&#x22;)
        if (isGetSet) this$1.raise(key.start, &#x22;Constructor can&#x27;t have get/set modifier&#x22;)
        if (isGenerator) this$1.raise(key.start, &#x22;Constructor can&#x27;t be a generator&#x22;)
        if (isAsync) this$1.raise(key.start, &#x22;Constructor can&#x27;t be an async method&#x22;)
        method.kind = &#x22;constructor&#x22;
        hadConstructor = true
      }
    }
    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)
    if (isGetSet) {
      var paramCount = method.kind === &#x22;get&#x22; ? 0 : 1
      if (method.value.params.length !== paramCount) {
        var start = method.value.start
        if (method.kind === &#x22;get&#x22;)
          this$1.raiseRecoverable(start, &#x22;getter should have no params&#x22;)
        else
          this$1.raiseRecoverable(start, &#x22;setter should have exactly one param&#x22;)
      } else {
        if (method.kind === &#x22;set&#x22; &#x26;&#x26; method.value.params[0].type === &#x22;RestElement&#x22;)
          this$1.raiseRecoverable(method.value.params[0].start, &#x22;Setter cannot use rest params&#x22;)
      }
    }
  }
  node.body = this.finishNode(classBody, &#x22;ClassBody&#x22;)
  return this.finishNode(node, isStatement ? &#x22;ClassDeclaration&#x22; : &#x22;ClassExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._do: return this.parseDoStatement(node)
case tt._for: return this.parseForStatement(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.<span class="apidocCodeKeywordSpan">parseClass</span>(node, true)
case tt._if: return this.parseIfStatement(node)
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClassId" id="apidoc.element.acorn.Parser.prototype.parseClassId">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassId
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClassId = function (node, isStatement) {
  node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
var this$1 = this;

this.next()

this.<span class="apidocCodeKeywordSpan">parseClassId</span>(node, isStatement)
this.parseClassSuper(node)
var classBody = this.startNode()
var hadConstructor = false
classBody.body = []
this.expect(tt.braceL)
while (!this.eat(tt.braceR)) {
  if (this$1.eat(tt.semi)) continue
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClassMethod" id="apidoc.element.acorn.Parser.prototype.parseClassMethod">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassMethod
        <span class="apidocSignatureSpan">(classBody, method, isGenerator, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync)
  classBody.body.push(this.finishNode(method, &#x22;MethodDefinition&#x22;))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isGetSet) this$1.raise(key.start, &#x22;Constructor can&#x27;t have get/set modifier&#x22;)
    if (isGenerator) this$1.raise(key.start, &#x22;Constructor can&#x27;t be a generator&#x22;)
    if (isAsync) this$1.raise(key.start, &#x22;Constructor can&#x27;t be an async method&#x22;)
    method.kind = &#x22;constructor&#x22;
    hadConstructor = true
  }
}
this$1.<span class="apidocCodeKeywordSpan">parseClassMethod</span>(classBody, method, isGenerator, isAsync)
if (isGetSet) {
  var paramCount = method.kind === &#x22;get&#x22; ? 0 : 1
  if (method.value.params.length !== paramCount) {
    var start = method.value.start
    if (method.kind === &#x22;get&#x22;)
      this$1.raiseRecoverable(start, &#x22;getter should have no params&#x22;)
    else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClassSuper" id="apidoc.element.acorn.Parser.prototype.parseClassSuper">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassSuper
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClassSuper = function (node) {
  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$1.parseClass = function(node, isStatement) {
var this$1 = this;

this.next()

this.parseClassId(node, isStatement)
this.<span class="apidocCodeKeywordSpan">parseClassSuper</span>(node)
var classBody = this.startNode()
var hadConstructor = false
classBody.body = []
this.expect(tt.braceL)
while (!this.eat(tt.braceR)) {
  if (this$1.eat(tt.semi)) continue
  var method = this$1.startNode()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseDebuggerStatement" id="apidoc.element.acorn.Parser.prototype.parseDebuggerStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDebuggerStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDebuggerStatement = function (node) {
  this.next()
  this.semicolon()
  return this.finishNode(node, &#x22;DebuggerStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case tt._debugger: return this.<span class="apidocCodeKeywordSpan">parseDebuggerStatement</span>(node)
case tt._do: return this.parseDoStatement(node)
case tt._for: return this.parseForStatement(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseDoStatement" id="apidoc.element.acorn.Parser.prototype.parseDoStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDoStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDoStatement = function (node) {
  this.next()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  this.expect(tt._while)
  node.test = this.parseParenExpression()
  if (this.options.ecmaVersion &#x3e;= 6)
    this.eat(tt.semi)
  else
    this.semicolon()
  return this.finishNode(node, &#x22;DoWhileStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Most types of statements are recognized by the keyword they
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case tt._debugger: return this.parseDebuggerStatement(node)
case tt._do: return this.<span class="apidocCodeKeywordSpan">parseDoStatement</span>(node)
case tt._for: return this.parseForStatement(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseEmptyStatement" id="apidoc.element.acorn.Parser.prototype.parseEmptyStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseEmptyStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseEmptyStatement = function (node) {
  this.next()
  return this.finishNode(node, &#x22;EmptyStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.parseWhileStatement(node)
case tt._with: return this.parseWithStatement(node)
case tt.braceL: return this.parseBlock()
case tt.semi: return this.<span class="apidocCodeKeywordSpan">parseEmptyStatement</span>(node)
case tt._export:
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level&#x22;)
    if (!this.inModule)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may appear only with &#x27;sourceType: module&#x27;&#
x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExport" id="apidoc.element.acorn.Parser.prototype.parseExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExport
        <span class="apidocSignatureSpan">(node, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExport = function (node, exports) {
  var this$1 = this;

  this.next()
  // export * from &#x27;...&#x27;
  if (this.eat(tt.star)) {
    this.expectContextual(&#x22;from&#x22;)
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
    this.semicolon()
    return this.finishNode(node, &#x22;ExportAllDeclaration&#x22;)
  }
  if (this.eat(tt._default)) { // export default ...
    this.checkExport(exports, &#x22;default&#x22;, this.lastTokStart)
    var isAsync
    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode()
      this.next()
      if (isAsync) this.next()
      node.declaration = this.parseFunction(fNode, &#x22;nullableID&#x22;, false, isAsync)
    } else if (this.type === tt._class) {
      var cNode = this.startNode()
      node.declaration = this.parseClass(cNode, &#x22;nullableID&#x22;)
    } else {
      node.declaration = this.parseMaybeAssign()
      this.semicolon()
    }
    return this.finishNode(node, &#x22;ExportDefaultDeclaration&#x22;)
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true)
    if (node.declaration.type === &#x22;VariableDeclaration&#x22;)
      this.checkVariableExport(exports, node.declaration.declarations)
    else
      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)
    node.specifiers = []
    node.source = null
  } else { // export { x, y as z } [from &#x27;...&#x27;]
    node.declaration = null
    node.specifiers = this.parseExportSpecifiers(exports)
    if (this.eatContextual(&#x22;from&#x22;)) {
      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
    } else {
      // check for keywords used as local names
      for (var i = 0; i &#x3c; node.specifiers.length; i++) {
        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
          this$1.unexpected(node.specifiers[i].local.start)
        }
      }

      node.source = null
    }
    this.semicolon()
  }
  return this.finishNode(node, &#x22;ExportNamedDeclaration&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level&#x22;)
    if (!this.inModule)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may appear only with &#x27;sourceType: module&#x27;&#
x22;)
  }
  return starttype === tt._import ? this.parseImport(node) : this.<span class="apidocCodeKeywordSpan">parseExport</span>(node, exports
)

  // If the statement does not start with a statement keyword or a
  // brace, it&#x27;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExportSpecifiers" id="apidoc.element.acorn.Parser.prototype.parseExportSpecifiers">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExportSpecifiers
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExportSpecifiers = function (exports) {
  var this$1 = this;

  var nodes = [], first = true
  // export { x, y as z } [from &#x27;...&#x27;]
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false

    var node = this$1.startNode()
    node.local = this$1.parseIdent(true)
    node.exported = this$1.eatContextual(&#x22;as&#x22;) ? this$1.parseIdent(true) : node.local
    this$1.checkExport(exports, node.exported.name, node.exported.start)
    nodes.push(this$1.finishNode(node, &#x22;ExportSpecifier&#x22;))
  }
  return nodes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.checkVariableExport(exports, node.declaration.declarations)
  else
    this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)
  node.specifiers = []
  node.source = null
} else { // export { x, y as z } [from &#x27;...&#x27;]
  node.declaration = null
  node.specifiers = this.<span class="apidocCodeKeywordSpan">parseExportSpecifiers</span>(exports)
  if (this.eatContextual(&#x22;from&#x22;)) {
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  } else {
    // check for keywords used as local names
    for (var i = 0; i &#x3c; node.specifiers.length; i++) {
      if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
        this$1.unexpected(node.specifiers[i].local.start)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprAtom" id="apidoc.element.acorn.Parser.prototype.parseExprAtom">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprAtom
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprAtom = function (refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt == this.start
  switch (this.type) {
  case tt._super:
    if (!this.inFunction)
      this.raise(this.start, &#x22;&#x27;super&#x27; outside of function or class&#x22;)

  case tt._this:
    var type = this.type === tt._this ? &#x22;ThisExpression&#x22; : &#x22;Super&#x22;
    node = this.startNode()
    this.next()
    return this.finishNode(node, type)

  case tt.name:
    var startPos = this.start, startLoc = this.startLoc
    var id = this.parseIdent(this.type !== tt.name)
    if (this.options.ecmaVersion &#x3e;= 8 &#x26;&#x26; id.name === &#x22;async&#x22; &#x26;&#x26; !this.canInsertSemicolon() &#x26;&#x26; this.eat(tt._function))
      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)
    if (canBeArrow &#x26;&#x26; !this.canInsertSemicolon()) {
      if (this.eat(tt.arrow))
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)
      if (this.options.ecmaVersion &#x3e;= 8 &#x26;&#x26; id.name === &#x22;async&#x22; &#x26;&#x26; this.type === tt.name) {
        id = this.parseIdent()
        if (this.canInsertSemicolon() || !this.eat(tt.arrow))
          this.unexpected()
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case tt.regexp:
    var value = this.value
    node = this.parseLiteral(value.value)
    node.regex = {pattern: value.pattern, flags: value.flags}
    return node

  case tt.num: case tt.string:
    return this.parseLiteral(this.value)

  case tt._null: case tt._true: case tt._false:
    node = this.startNode()
    node.value = this.type === tt._null ? null : this.type === tt._true
    node.raw = this.type.keyword
    this.next()
    return this.finishNode(node, &#x22;Literal&#x22;)

  case tt.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &#x3c; 0 &#x26;&#x26; !this.isSimpleAssignTarget(expr))
        refDestructuringErrors.parenthesizedAssign = start
      if (refDestructuringErrors.parenthesizedBind &#x3c; 0)
        refDestructuringErrors.parenthesizedBind = start
    }
    return expr

  case tt.bracketL:
    node = this.startNode()
    this.next()
    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
    return this.finishNode(node, &#x22;ArrayExpression&#x22;)

  case tt.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case tt._function:
    node = this.startNode()
    this.next()
    return this.parseFunction(node, false)

  case tt._class:
    return this.parseClass(this.startNode(), false)

  case tt._new:
    return this.parseNew()

  case tt.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$1.parseExport = function(node, exports) {
var this$1 = this;

this.next()
// export * from &#x27;...&#x27;
if (this.eat(tt.star)) {
  this.expectContextual(&#x22;from&#x22;)
  node.source = this.type === tt.string ? this.<span class="apidocCodeKeywordSpan">parseExprAtom</span>() : this.unexpected()
  this.semicolon()
  return this.finishNode(node, &#x22;ExportAllDeclaration&#x22;)
}
if (this.eat(tt._default)) { // export default ...
  this.checkExport(exports, &#x22;default&#x22;, this.lastTokStart)
  var isAsync
  if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprList" id="apidoc.element.acorn.Parser.prototype.parseExprList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprList
        <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(close)) break
    } else first = false

    var elt
    if (allowEmpty &#x26;&#x26; this$1.type === tt.comma)
      elt = null
    else if (this$1.type === tt.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors)
      if (refDestructuringErrors &#x26;&#x26; this$1.type === tt.comma &#x26;&#x26; refDestructuringErrors.trailingComma &#x3c; 0)
        refDestructuringErrors.trailingComma = this$1.start
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
    }
    elts.push(elt)
  }
  return elts
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  node.computed = !!computed
  if (computed) this$1.expect(tt.bracketR)
  base = this$1.finishNode(node, &#x22;MemberExpression&#x22;)
} else if (!noCalls &#x26;&#x26; this$1.eat(tt.parenL)) {
  var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos
  this$1.yieldPos = 0
  this$1.awaitPos = 0
  var exprList = this$1.<span class="apidocCodeKeywordSpan">parseExprList</span>(tt.parenR, this$1.options.ecmaVersion &#x3e;= 8
, false, refDestructuringErrors)
  if (maybeAsyncArrow &#x26;&#x26; !this$1.canInsertSemicolon() &#x26;&#x26; this$1.eat(tt.arrow)) {
    this$1.checkPatternErrors(refDestructuringErrors, false)
    this$1.checkYieldAwaitInDefaultParams()
    this$1.yieldPos = oldYieldPos
    this$1.awaitPos = oldAwaitPos
    return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprOp" id="apidoc.element.acorn.Parser.prototype.parseExprOp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOp
        <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop
  if (prec != null &#x26;&#x26; (!noIn || this.type !== tt._in)) {
    if (prec &#x3e; minPrec) {
      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND
      var op = this.value
      this.next()
      var startPos = this.start, startLoc = this.startLoc
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseMaybeUnary(refDestructuringErrors, false)
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  return expr.start == startPos &#x26;&#x26; expr.type === &#x22;ArrowFunctionExpression&#x22; ? expr : this.<span class="apidocCodeKeywordSpan
">parseExprOp</span>(expr, startPos, startLoc, -1, noIn)
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprOps" id="apidoc.element.acorn.Parser.prototype.parseExprOps">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOps
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseMaybeUnary(refDestructuringErrors, false)
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  return expr.start == startPos &#x26;&#x26; expr.type === &#x22;ArrowFunctionExpression&#x22; ? expr : this.parseExprOp(expr, startPos, startLoc, -
1, noIn)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return left
}

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
var startPos = this.start, startLoc = this.startLoc
var expr = this.<span class="apidocCodeKeywordSpan">parseExprOps</span>(noIn, refDestructuringErrors)
if (this.checkExpressionErrors(refDestructuringErrors)) return expr
if (this.eat(tt.question)) {
  var node = this.startNodeAt(startPos, startLoc)
  node.test = expr
  node.consequent = this.parseMaybeAssign()
  this.expect(tt.colon)
  node.alternate = this.parseMaybeAssign(noIn)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprSubscripts" id="apidoc.element.acorn.Parser.prototype.parseExprSubscripts">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprSubscripts
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseExprAtom(refDestructuringErrors)
  var skipArrowSubscripts = expr.type === &#x22;ArrowFunctionExpression&#x22; &#x26;&#x26; this.input.slice(this.lastTokStart, this.lastTokEnd) !== &#x22;)&#x22;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
  var result = this.parseSubscripts(expr, startPos, startLoc)
  if (refDestructuringErrors &#x26;&#x26; result.type === &#x22;MemberExpression&#x22;) {
    if (refDestructuringErrors.parenthesizedAssign &#x3e;= result.start) refDestructuringErrors.parenthesizedAssign = -1
    if (refDestructuringErrors.parenthesizedBind &#x3e;= result.start) refDestructuringErrors.parenthesizedBind = -1
  }
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

pp$1.parseClassId = function(node, isStatement) {
node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null
}

pp$1.parseClassSuper = function(node) {
node.superClass = this.eat(tt._extends) ? this.<span class="apidocCodeKeywordSpan">parseExprSubscripts</span>() : null
}

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
var this$1 = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExpression" id="apidoc.element.acorn.Parser.prototype.parseExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpression
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpression = function (noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
  if (this.type === tt.comma) {
    var node = this.startNodeAt(startPos, startLoc)
    node.expressions = [expr]
    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))
    return this.finishNode(node, &#x22;SequenceExpression&#x22;)
  }
  return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction() &#x26;&#x26; declaration) {
      this.next()
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.<span class="apidocCodeKeywordSpan">parseExpression</span>()
    if (starttype === tt.name &#x26;&#x26; expr.type === &#x22;Identifier&#x22; &#x26;&#x26; this.eat(tt.colon))
      return this.parseLabeledStatement(node, maybeName, expr)
    else return this.parseExpressionStatement(node, expr)
  }
}

pp$1.parseBreakContinueStatement = function(node, keyword) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExpressionStatement" id="apidoc.element.acorn.Parser.prototype.parseExpressionStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpressionStatement
        <span class="apidocSignatureSpan">(node, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpressionStatement = function (node, expr) {
  node.expression = expr
  this.semicolon()
  return this.finishNode(node, &#x22;ExpressionStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.next()
    return this.parseFunctionStatement(node, true)
  }

  var maybeName = this.value, expr = this.parseExpression()
  if (starttype === tt.name &#x26;&#x26; expr.type === &#x22;Identifier&#x22; &#x26;&#x26; this.eat(tt.colon))
    return this.parseLabeledStatement(node, maybeName, expr)
  else return this.<span class="apidocCodeKeywordSpan">parseExpressionStatement</span>(node, expr)
}
}

pp$1.parseBreakContinueStatement = function(node, keyword) {
var this$1 = this;

var isBreak = keyword == &#x22;break&#x22;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFor" id="apidoc.element.acorn.Parser.prototype.parseFor">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFor
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFor = function (node, init) {
  node.init = init
  this.expect(tt.semi)
  node.test = this.type === tt.semi ? null : this.parseExpression()
  this.expect(tt.semi)
  node.update = this.type === tt.parenR ? null : this.parseExpression()
  this.expect(tt.parenR)
  this.exitLexicalScope()
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, &#x22;ForStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
this.next()
this.labels.push(loopLabel)
this.enterLexicalScope()
this.expect(tt.parenL)
if (this.type === tt.semi) return this.<span class="apidocCodeKeywordSpan">parseFor</span>(node, null)
var isLet = this.isLet()
if (this.type === tt._var || this.type === tt._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &#x22;let&#x22; : this.value
  this.next()
  this.parseVar(init$1, true, kind)
  this.finishNode(init$1, &#x22;VariableDeclaration&#x22;)
  if ((this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) &#x26;&#x26;
init$1.declarations.length === 1 &#x26;&#x26;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseForIn" id="apidoc.element.acorn.Parser.prototype.parseForIn">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForIn
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseForIn = function (node, init) {
  var type = this.type === tt._in ? &#x22;ForInStatement&#x22; : &#x22;ForOfStatement&#x22;
  this.next()
  node.left = init
  node.right = this.parseExpression()
  this.expect(tt.parenR)
  this.exitLexicalScope()
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.type === tt._var || this.type === tt._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &#x22;let&#x22; : this.value
  this.next()
  this.parseVar(init$1, true, kind)
  this.finishNode(init$1, &#x22;VariableDeclaration&#x22;)
  if ((this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) &#x26;&#x26;
init$1.declarations.length === 1 &#x26;&#x26;
      !(kind !== &#x22;var&#x22; &#x26;&#x26; init$1.declarations[0].init))
    return this.<span class="apidocCodeKeywordSpan">parseForIn</span>(node, init$1)
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors
var init = this.parseExpression(true, refDestructuringErrors)
if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
  this.toAssignable(init)
  this.checkLVal(init)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseForStatement" id="apidoc.element.acorn.Parser.prototype.parseForStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseForStatement = function (node) {
  this.next()
  this.labels.push(loopLabel)
  this.enterLexicalScope()
  this.expect(tt.parenL)
  if (this.type === tt.semi) return this.parseFor(node, null)
  var isLet = this.isLet()
  if (this.type === tt._var || this.type === tt._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? &#x22;let&#x22; : this.value
    this.next()
    this.parseVar(init$1, true, kind)
    this.finishNode(init$1, &#x22;VariableDeclaration&#x22;)
    if ((this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) &#x26;&#x26; init$1.declarations.length === 1
 &#x26;&#x26;
        !(kind !== &#x22;var&#x22; &#x26;&#x26; init$1.declarations[0].init))
      return this.parseForIn(node, init$1)
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors
  var init = this.parseExpression(true, refDestructuringErrors)
  if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
    this.toAssignable(init)
    this.checkLVal(init)
    this.checkPatternErrors(refDestructuringErrors, true)
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true)
  }
  return this.parseFor(node, init)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// start with. Many are trivial to parse, some require a bit of
// complexity.

switch (starttype) {
case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case tt._debugger: return this.parseDebuggerStatement(node)
case tt._do: return this.parseDoStatement(node)
case tt._for: return this.<span class="apidocCodeKeywordSpan">parseForStatement</span>(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.parseIfStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunction" id="apidoc.element.acorn.Parser.prototype.parseFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunction
        <span class="apidocSignatureSpan">(node, isStatement, allowExpressionBody, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node)
  if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; !isAsync)
    node.generator = this.eat(tt.star)
  if (this.options.ecmaVersion &#x3e;= 8)
    node.async = !!isAsync

  if (isStatement) {
    node.id = isStatement === &#x22;nullableID&#x22; &#x26;&#x26; this.type != tt.name ? null : this.parseIdent()
    if (node.id) {
      this.checkLVal(node.id, &#x22;var&#x22;)
    }
  }

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction
  this.inGenerator = node.generator
  this.inAsync = node.async
  this.yieldPos = 0
  this.awaitPos = 0
  this.inFunction = true
  this.enterFunctionScope()

  if (!isStatement)
    node.id = this.type == tt.name ? this.parseIdent() : null

  this.parseFunctionParams(node)
  this.parseFunctionBody(node, allowExpressionBody)

  this.inGenerator = oldInGen
  this.inAsync = oldInAsync
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, isStatement ? &#x22;FunctionDeclaration&#x22; : &#x22;FunctionExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.checkExpressionErrors(refDestructuringErrors, true)
  }
  return this.parseFor(node, init)
}

pp$1.parseFunctionStatement = function(node, isAsync) {
  this.next()
  return this.<span class="apidocCodeKeywordSpan">parseFunction</span>(node, true, false, isAsync)
}

pp$1.isFunction = function() {
  return this.type === tt._function || this.isAsyncFunction()
}

pp$1.parseIfStatement = function(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunctionBody" id="apidoc.element.acorn.Parser.prototype.parseFunctionBody">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionBody
        <span class="apidocSignatureSpan">(node, isArrowFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction &#x26;&#x26; this.type !== tt.braceL
  var oldStrict = this.strict, useStrict = false

  if (isExpression) {
    node.body = this.parseMaybeAssign()
    node.expression = true
    this.checkParams(node, false)
  } else {
    var nonSimple = this.options.ecmaVersion &#x3e;= 7 &#x26;&#x26; !this.isSimpleParamList(node.params)
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end)
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict &#x26;&#x26; nonSimple)
        this.raiseRecoverable(node.start, &#x22;Illegal &#x27;use strict&#x27; directive in function with non-simple parameter list&#x22;)
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels
    this.labels = []
    if (useStrict) this.strict = true

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &#x26;&#x26; !useStrict &#x26;&#x26; !isArrowFunction &#x26;&#x26; this.isSimpleParamList(node.params))
    node.body = this.parseBlock(false)
    node.expression = false
    this.labels = oldLabels
  }
  this.exitFunctionScope()

  if (this.strict &#x26;&#x26; node.id) {
    // Ensure the function name isn&#x27;t a forbidden identifier in strict mode, e.g. &#x27;eval&#x27;
    this.checkLVal(node.id, &#x22;none&#x22;)
  }
  this.strict = oldStrict
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.inFunction = true
this.enterFunctionScope()

if (!isStatement)
  node.id = this.type == tt.name ? this.parseIdent() : null

this.parseFunctionParams(node)
this.<span class="apidocCodeKeywordSpan">parseFunctionBody</span>(node, allowExpressionBody)

this.inGenerator = oldInGen
this.inAsync = oldInAsync
this.yieldPos = oldYieldPos
this.awaitPos = oldAwaitPos
this.inFunction = oldInFunc
return this.finishNode(node, isStatement ? &#x22;FunctionDeclaration&#x22; : &#x22;FunctionExpression&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunctionParams" id="apidoc.element.acorn.Parser.prototype.parseFunctionParams">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionParams
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunctionParams = function (node) {
  this.expect(tt.parenL)
  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion &#x3e;= 8, true)
  this.checkYieldAwaitInDefaultParams()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.awaitPos = 0
this.inFunction = true
this.enterFunctionScope()

if (!isStatement)
  node.id = this.type == tt.name ? this.parseIdent() : null

this.<span class="apidocCodeKeywordSpan">parseFunctionParams</span>(node)
this.parseFunctionBody(node, allowExpressionBody)

this.inGenerator = oldInGen
this.inAsync = oldInAsync
this.yieldPos = oldYieldPos
this.awaitPos = oldAwaitPos
this.inFunction = oldInFunc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunctionStatement" id="apidoc.element.acorn.Parser.prototype.parseFunctionStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionStatement
        <span class="apidocSignatureSpan">(node, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunctionStatement = function (node, isAsync) {
  this.next()
  return this.parseFunction(node, true, false, isAsync)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
switch (starttype) {
case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
case tt._debugger: return this.parseDebuggerStatement(node)
case tt._do: return this.parseDoStatement(node)
case tt._for: return this.parseForStatement(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.<span class="apidocCodeKeywordSpan">parseFunctionStatement</span>(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.parseIfStatement(node)
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseIdent" id="apidoc.element.acorn.Parser.prototype.parseIdent">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIdent
        <span class="apidocSignatureSpan">(liberal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseIdent = function (liberal) {
  var node = this.startNode()
  if (liberal &#x26;&#x26; this.options.allowReserved == &#x22;never&#x22;) liberal = false
  if (this.type === tt.name) {
    if (!liberal &#x26;&#x26; (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &#x26;&#x26;
        (this.options.ecmaVersion &#x3e;= 6 ||
         this.input.slice(this.start, this.end).indexOf(&#x22;\\&#x22;) == -1))
      this.raiseRecoverable(this.start, &#x22;The keyword &#x27;&#x22; + this.value + &#x22;&#x27; is reserved&#x22;)
    if (this.inGenerator &#x26;&#x26; this.value === &#x22;yield&#x22;)
      this.raiseRecoverable(this.start, &#x22;Can not use &#x27;yield&#x27; as identifier inside a generator&#x22;)
    if (this.inAsync &#x26;&#x26; this.value === &#x22;await&#x22;)
      this.raiseRecoverable(this.start, &#x22;Can not use &#x27;await&#x27; as identifier inside an async function&#x22;)
    node.name = this.value
  } else if (liberal &#x26;&#x26; this.type.keyword) {
    node.name = this.type.keyword
  } else {
    this.unexpected()
  }
  this.next()
  return this.finishNode(node, &#x22;Identifier&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var this$1 = this;

var isBreak = keyword == &#x22;break&#x22;
this.next()
if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
else if (this.type !== tt.name) this.unexpected()
else {
  node.label = this.<span class="apidocCodeKeywordSpan">parseIdent</span>()
  this.semicolon()
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0
for (; i &#x3c; this.labels.length; ++i) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseIfStatement" id="apidoc.element.acorn.Parser.prototype.parseIfStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIfStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseIfStatement = function (node) {
  this.next()
  node.test = this.parseParenExpression()
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict &#x26;&#x26; this.isFunction())
  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict &#x26;&#x26; this.isFunction()) : null
  return this.finishNode(node, &#x22;IfStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._for: return this.parseForStatement(node)
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.<span class="apidocCodeKeywordSpan">parseIfStatement</span>(node)
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseImport" id="apidoc.element.acorn.Parser.prototype.parseImport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImport
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseImport = function (node) {
  this.next()
  // import &#x27;...&#x27;
  if (this.type === tt.string) {
    node.specifiers = empty
    node.source = this.parseExprAtom()
  } else {
    node.specifiers = this.parseImportSpecifiers()
    this.expectContextual(&#x22;from&#x22;)
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  }
  this.semicolon()
  return this.finishNode(node, &#x22;ImportDeclaration&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level&#x22;)
    if (!this.inModule)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may appear only with &#x27;sourceType: module&#x27;&#
x22;)
  }
  return starttype === tt._import ? this.<span class="apidocCodeKeywordSpan">parseImport</span>(node) : this.parseExport(node, exports
)

  // If the statement does not start with a statement keyword or a
  // brace, it&#x27;s an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseImportSpecifiers" id="apidoc.element.acorn.Parser.prototype.parseImportSpecifiers">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImportSpecifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseImportSpecifiers = function () {
  var this$1 = this;

  var nodes = [], first = true
  if (this.type === tt.name) {
    // import defaultObj, { x, y as z } from &#x27;...&#x27;
    var node = this.startNode()
    node.local = this.parseIdent()
    this.checkLVal(node.local, &#x22;let&#x22;)
    nodes.push(this.finishNode(node, &#x22;ImportDefaultSpecifier&#x22;))
    if (!this.eat(tt.comma)) return nodes
  }
  if (this.type === tt.star) {
    var node$1 = this.startNode()
    this.next()
    this.expectContextual(&#x22;as&#x22;)
    node$1.local = this.parseIdent()
    this.checkLVal(node$1.local, &#x22;let&#x22;)
    nodes.push(this.finishNode(node$1, &#x22;ImportNamespaceSpecifier&#x22;))
    return nodes
  }
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false

    var node$2 = this$1.startNode()
    node$2.imported = this$1.parseIdent(true)
    if (this$1.eatContextual(&#x22;as&#x22;)) {
      node$2.local = this$1.parseIdent()
    } else {
      node$2.local = node$2.imported
      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)
      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, &#x22;The keyword &#x27;&#x22; + node
$2.local.name + &#x22;&#x27; is reserved&#x22;)
    }
    this$1.checkLVal(node$2.local, &#x22;let&#x22;)
    nodes.push(this$1.finishNode(node$2, &#x22;ImportSpecifier&#x22;))
  }
  return nodes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$1.parseImport = function(node) {
  this.next()
  // import &#x27;...&#x27;
  if (this.type === tt.string) {
    node.specifiers = empty
    node.source = this.parseExprAtom()
  } else {
    node.specifiers = this.<span class="apidocCodeKeywordSpan">parseImportSpecifiers</span>()
    this.expectContextual(&#x22;from&#x22;)
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  }
  this.semicolon()
  return this.finishNode(node, &#x22;ImportDeclaration&#x22;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseLabeledStatement" id="apidoc.element.acorn.Parser.prototype.parseLabeledStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLabeledStatement
        <span class="apidocSignatureSpan">(node, maybeName, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseLabeledStatement = function (node, maybeName, expr) {
  var this$1 = this;

  for (var i = 0; i &#x3c; this.labels.length; ++i)
    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, &#x22;Label &#x27;&#x22; + maybeName + &#x22;&#x27; is already declared&#x22;)
  var kind = this.type.isLoop ? &#x22;loop&#x22; : this.type === tt._switch ? &#x22;switch&#x22; : null
  for (var i$1 = this.labels.length - 1; i$1 &#x3e;= 0; i$1--) {
    var label = this$1.labels[i$1]
    if (label.statementStart == node.start) {
      label.statementStart = this$1.start
      label.kind = kind
    } else break
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})
  node.body = this.parseStatement(true)
  if (node.body.type == &#x22;ClassDeclaration&#x22; ||
      node.body.type == &#x22;VariableDeclaration&#x22; &#x26;&#x26; node.body.kind != &#x22;var&#x22; ||
      node.body.type == &#x22;FunctionDeclaration&#x22; &#x26;&#x26; (this.strict || node.body.generator))
    this.raiseRecoverable(node.body.start, &#x22;Invalid labeled declaration&#x22;)
  this.labels.pop()
  node.label = expr
  return this.finishNode(node, &#x22;LabeledStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.isAsyncFunction() &#x26;&#x26; declaration) {
    this.next()
    return this.parseFunctionStatement(node, true)
  }

  var maybeName = this.value, expr = this.parseExpression()
  if (starttype === tt.name &#x26;&#x26; expr.type === &#x22;Identifier&#x22; &#x26;&#x26; this.eat(tt.colon))
    return this.<span class="apidocCodeKeywordSpan">parseLabeledStatement</span>(node, maybeName, expr)
  else return this.parseExpressionStatement(node, expr)
}
}

pp$1.parseBreakContinueStatement = function(node, keyword) {
var this$1 = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseLiteral" id="apidoc.element.acorn.Parser.prototype.parseLiteral">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseLiteral = function (value) {
  var node = this.startNode()
  node.value = value
  node.raw = this.input.slice(this.start, this.end)
  this.next()
  return this.finishNode(node, &#x22;Literal&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
    }
  }
  return id

case tt.regexp:
  var value = this.value
  node = this.<span class="apidocCodeKeywordSpan">parseLiteral</span>(value.value)
  node.regex = {pattern: value.pattern, flags: value.flags}
  return node

case tt.num: case tt.string:
  return this.parseLiteral(this.value)

case tt._null: case tt._true: case tt._false:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeAssign" id="apidoc.element.acorn.Parser.prototype.parseMaybeAssign">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeAssign
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator &#x26;&#x26; this.isContextual(&#x22;yield&#x22;)) return this.parseYield()

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign
    oldTrailingComma = refDestructuringErrors.trailingComma
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1
  } else {
    refDestructuringErrors = new DestructuringErrors
    ownDestructuringErrors = true
  }

  var startPos = this.start, startLoc = this.startLoc
  if (this.type == tt.parenL || this.type == tt.name)
    this.potentialArrowAt = this.start
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
  if (this.type.isAssign) {
    this.checkPatternErrors(refDestructuringErrors, true)
    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)
    var node = this.startNodeAt(startPos, startLoc)
    node.operator = this.value
    node.left = this.type === tt.eq ? this.toAssignable(left) : left
    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly
    this.checkLVal(left)
    this.next()
    node.right = this.parseMaybeAssign(noIn)
    return this.finishNode(node, &#x22;AssignmentExpression&#x22;)
  } else {
    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)
  }
  if (oldParenAssign &#x3e; -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign
  if (oldTrailingComma &#x3e; -1) refDestructuringErrors.trailingComma = oldTrailingComma
  return left
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

node.declarations = []
node.kind = kind
for (;;) {
  var decl = this$1.startNode()
  this$1.parseVarId(decl, kind)
  if (this$1.eat(tt.eq)) {
    decl.init = this$1.<span class="apidocCodeKeywordSpan">parseMaybeAssign</span>(isFor)
  } else if (kind === &#x22;const&#x22; &#x26;&#x26; !(this$1.type === tt._in || (this$1.options.ecmaVersion &#x3e;= 6 &#x26;&#x26
; this$1.isContextual(&#x22;of&#x22;)))) {
    this$1.unexpected()
  } else if (decl.id.type != &#x22;Identifier&#x22; &#x26;&#x26; !(isFor &#x26;&#x26; (this$1.type === tt._in || this$1.isContextual
(&#x22;of&#x22;)))) {
    this$1.raise(this$1.lastTokEnd, &#x22;Complex binding patterns require an initialization value&#x22;)
  } else {
    decl.init = null
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeConditional" id="apidoc.element.acorn.Parser.prototype.parseMaybeConditional">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeConditional
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseExprOps(noIn, refDestructuringErrors)
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  if (this.eat(tt.question)) {
    var node = this.startNodeAt(startPos, startLoc)
    node.test = expr
    node.consequent = this.parseMaybeAssign()
    this.expect(tt.colon)
    node.alternate = this.parseMaybeAssign(noIn)
    return this.finishNode(node, &#x22;ConditionalExpression&#x22;)
  }
  return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  refDestructuringErrors = new DestructuringErrors
  ownDestructuringErrors = true
}

var startPos = this.start, startLoc = this.startLoc
if (this.type == tt.parenL || this.type == tt.name)
  this.potentialArrowAt = this.start
var left = this.<span class="apidocCodeKeywordSpan">parseMaybeConditional</span>(noIn, refDestructuringErrors)
if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
if (this.type.isAssign) {
  this.checkPatternErrors(refDestructuringErrors, true)
  if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)
  var node = this.startNodeAt(startPos, startLoc)
  node.operator = this.value
  node.left = this.type === tt.eq ? this.toAssignable(left) : left
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeDefault" id="apidoc.element.acorn.Parser.prototype.parseMaybeDefault">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeDefault
        <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom()
  if (this.options.ecmaVersion &#x3c; 6 || !this.eat(tt.eq)) return left
  var node = this.startNodeAt(startPos, startLoc)
  node.left = left
  node.right = this.parseMaybeAssign()
  return this.finishNode(node, &#x22;AssignmentPattern&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var rest = this$1.parseRest(allowNonIdent)
      this$1.parseBindingListItem(rest)
      elts.push(rest)
      if (this$1.type === tt.comma) this$1.raise(this$1.start, &#x22;Comma is not permitted after the rest element&#x22;)
      this$1.expect(close)
      break
    } else {
      var elem = this$1.<span class="apidocCodeKeywordSpan">parseMaybeDefault</span>(this$1.start, this$1.startLoc)
      this$1.parseBindingListItem(elem)
      elts.push(elem)
    }
  }
  return elts
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeUnary" id="apidoc.element.acorn.Parser.prototype.parseMaybeUnary">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeUnary
        <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr
  if (this.inAsync &#x26;&#x26; this.isContextual(&#x22;await&#x22;)) {
    expr = this.parseAwait(refDestructuringErrors)
    sawUnary = true
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === tt.incDec
    node.operator = this.value
    node.prefix = true
    this.next()
    node.argument = this.parseMaybeUnary(null, true)
    this.checkExpressionErrors(refDestructuringErrors, true)
    if (update) this.checkLVal(node.argument)
    else if (this.strict &#x26;&#x26; node.operator === &#x22;delete&#x22; &#x26;&#x26;
             node.argument.type === &#x22;Identifier&#x22;)
      this.raiseRecoverable(node.start, &#x22;Deleting local variable in strict mode&#x22;)
    else sawUnary = true
    expr = this.finishNode(node, update ? &#x22;UpdateExpression&#x22; : &#x22;UnaryExpression&#x22;)
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors)
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
    while (this.type.postfix &#x26;&#x26; !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc)
      node$1.operator = this$1.value
      node$1.prefix = false
      node$1.argument = expr
      this$1.checkLVal(expr)
      this$1.next()
      expr = this$1.finishNode(node$1, &#x22;UpdateExpression&#x22;)
    }
  }

  if (!sawUnary &#x26;&#x26; this.eat(tt.starstar))
    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), &#x22;**&#x22;, false)
  else
    return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return expr
}

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.<span class="apidocCodeKeywordSpan">parseMaybeUnary</span>(refDestructuringErrors, false)
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  return expr.start == startPos &#x26;&#x26; expr.type === &#x22;ArrowFunctionExpression&#x22; ? expr : this.parseExprOp(expr, startPos
, startLoc, -1, noIn)
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMethod" id="apidoc.element.acorn.Parser.prototype.parseMethod">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMethod
        <span class="apidocSignatureSpan">(isGenerator, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction

  this.initFunction(node)
  if (this.options.ecmaVersion &#x3e;= 6)
    node.generator = isGenerator
  if (this.options.ecmaVersion &#x3e;= 8)
    node.async = !!isAsync

  this.inGenerator = node.generator
  this.inAsync = node.async
  this.yieldPos = 0
  this.awaitPos = 0
  this.inFunction = true
  this.enterFunctionScope()

  this.expect(tt.parenL)
  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion &#x3e;= 8)
  this.checkYieldAwaitInDefaultParams()
  this.parseFunctionBody(node, false)

  this.inGenerator = oldInGen
  this.inAsync = oldInAsync
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, &#x22;FunctionExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  node.body = this.finishNode(classBody, &#x22;ClassBody&#x22;)
  return this.finishNode(node, isStatement ? &#x22;ClassDeclaration&#x22; : &#x22;ClassExpression&#x22;)
}

pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
  method.value = this.<span class="apidocCodeKeywordSpan">parseMethod</span>(isGenerator, isAsync)
  classBody.body.push(this.finishNode(method, &#x22;MethodDefinition&#x22;))
}

pp$1.parseClassId = function(node, isStatement) {
  node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseNew" id="apidoc.element.acorn.Parser.prototype.parseNew">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseNew
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseNew = function () {
  var node = this.startNode()
  var meta = this.parseIdent(true)
  if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.eat(tt.dot)) {
    node.meta = meta
    node.property = this.parseIdent(true)
    if (node.property.name !== &#x22;target&#x22;)
      this.raiseRecoverable(node.property.start, &#x22;The only valid meta property for new is new.target&#x22;)
    if (!this.inFunction)
      this.raiseRecoverable(node.start, &#x22;new.target can only be used in functions&#x22;)
    return this.finishNode(node, &#x22;MetaProperty&#x22;)
  }
  var startPos = this.start, startLoc = this.startLoc
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion &#x3e;= 8, false)
  else node.arguments = empty$1
  return this.finishNode(node, &#x22;NewExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.next()
  return this.parseFunction(node, false)

case tt._class:
  return this.parseClass(this.startNode(), false)

case tt._new:
  return this.<span class="apidocCodeKeywordSpan">parseNew</span>()

case tt.backQuote:
  return this.parseTemplate()

default:
  this.unexpected()
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseObj" id="apidoc.element.acorn.Parser.prototype.parseObj">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseObj
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseObj = function (isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {}
  node.properties = []
  this.next()
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false

    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc
    if (this$1.options.ecmaVersion &#x3e;= 6) {
      prop.method = false
      prop.shorthand = false
      if (isPattern || refDestructuringErrors) {
        startPos = this$1.start
        startLoc = this$1.startLoc
      }
      if (!isPattern)
        isGenerator = this$1.eat(tt.star)
    }
    this$1.parsePropertyName(prop)
    if (!isPattern &#x26;&#x26; this$1.options.ecmaVersion &#x3e;= 8 &#x26;&#x26; !isGenerator &#x26;&#x26; !prop.computed &#x26;&#x26;
        prop.key.type === &#x22;Identifier&#x22; &#x26;&#x26; prop.key.name === &#x22;async&#x22; &#x26;&#x26; this$1.type !== tt.parenL &#x26;&#x26;
        this$1.type !== tt.colon &#x26;&#x26; !this$1.canInsertSemicolon()) {
      isAsync = true
      this$1.parsePropertyName(prop, refDestructuringErrors)
    } else {
      isAsync = false
    }
    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)
    this$1.checkPropClash(prop, propHash)
    node.properties.push(this$1.finishNode(prop, &#x22;Property&#x22;))
  }
  return this.finishNode(node, isPattern ? &#x22;ObjectPattern&#x22; : &#x22;ObjectExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case tt.bracketL:
    var node = this.startNode()
    this.next()
    node.elements = this.parseBindingList(tt.bracketR, true, true)
    return this.finishNode(node, &#x22;ArrayPattern&#x22;)

  case tt.braceL:
    return this.<span class="apidocCodeKeywordSpan">parseObj</span>(true)

  default:
    this.unexpected()
  }
}

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenAndDistinguishExpression" id="apidoc.element.acorn.Parser.prototype.parseParenAndDistinguishExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenAndDistinguishExpression
        <span class="apidocSignatureSpan">(canBeArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenAndDistinguishExpression = function (canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion &#x3e;= 8
  if (this.options.ecmaVersion &#x3e;= 6) {
    this.next()

    var innerStartPos = this.start, innerStartLoc = this.startLoc
    var exprList = [], first = true, lastIsComma = false
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart,
innerParenStart
    this.yieldPos = 0
    this.awaitPos = 0
    while (this.type !== tt.parenR) {
      first ? first = false : this$1.expect(tt.comma)
      if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(tt.parenR, true)) {
        lastIsComma = true
        break
      } else if (this$1.type === tt.ellipsis) {
        spreadStart = this$1.start
        exprList.push(this$1.parseParenItem(this$1.parseRest()))
        if (this$1.type === tt.comma) this$1.raise(this$1.start, &#x22;Comma is not permitted after the rest element&#x22;)
        break
      } else {
        if (this$1.type === tt.parenL &#x26;&#x26; !innerParenStart) {
          innerParenStart = this$1.start
        }
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc
    this.expect(tt.parenR)

    if (canBeArrow &#x26;&#x26; !this.canInsertSemicolon() &#x26;&#x26; this.eat(tt.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false)
      this.checkYieldAwaitInDefaultParams()
      if (innerParenStart) this.unexpected(innerParenStart)
      this.yieldPos = oldYieldPos
      this.awaitPos = oldAwaitPos
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)
    if (spreadStart) this.unexpected(spreadStart)
    this.checkExpressionErrors(refDestructuringErrors, true)
    this.yieldPos = oldYieldPos || this.yieldPos
    this.awaitPos = oldAwaitPos || this.awaitPos

    if (exprList.length &#x3e; 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc)
      val.expressions = exprList
      this.finishNodeAt(val, &#x22;SequenceExpression&#x22;, innerEndPos, innerEndLoc)
    } else {
      val = exprList[0]
    }
  } else {
    val = this.parseParenExpression()
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc)
    par.expression = val
    return this.finishNode(par, &#x22;ParenthesizedExpression&#x22;)
  } else {
    return val
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  node = this.startNode()
  node.value = this.type === tt._null ? null : this.type === tt._true
  node.raw = this.type.keyword
  this.next()
  return this.finishNode(node, &#x22;Literal&#x22;)

case tt.parenL:
  var start = this.start, expr = this.<span class="apidocCodeKeywordSpan">parseParenAndDistinguishExpression</span>(canBeArrow)
  if (refDestructuringErrors) {
    if (refDestructuringErrors.parenthesizedAssign &#x3c; 0 &#x26;&#x26; !this.isSimpleAssignTarget(expr))
      refDestructuringErrors.parenthesizedAssign = start
    if (refDestructuringErrors.parenthesizedBind &#x3c; 0)
      refDestructuringErrors.parenthesizedBind = start
  }
  return expr
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenArrowList" id="apidoc.element.acorn.Parser.prototype.parseParenArrowList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenArrowList
        <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (canBeArrow &#x26;&#x26; !this.canInsertSemicolon() &#x26;&#x26; this.eat(tt.arrow)) {
  this.checkPatternErrors(refDestructuringErrors, false)
  this.checkYieldAwaitInDefaultParams()
  if (innerParenStart) this.unexpected(innerParenStart)
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  return this.<span class="apidocCodeKeywordSpan">parseParenArrowList</span>(startPos, startLoc, exprList)
}

if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)
if (spreadStart) this.unexpected(spreadStart)
this.checkExpressionErrors(refDestructuringErrors, true)
this.yieldPos = oldYieldPos || this.yieldPos
this.awaitPos = oldAwaitPos || this.awaitPos
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenExpression" id="apidoc.element.acorn.Parser.prototype.parseParenExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenExpression = function () {
  this.expect(tt.parenL)
  var val = this.parseExpression()
  this.expect(tt.parenR)
  return val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$1.parseDoStatement = function(node) {
  this.next()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  this.expect(tt._while)
  node.test = this.<span class="apidocCodeKeywordSpan">parseParenExpression</span>()
  if (this.options.ecmaVersion &#x3e;= 6)
    this.eat(tt.semi)
  else
    this.semicolon()
  return this.finishNode(node, &#x22;DoWhileStatement&#x22;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenItem" id="apidoc.element.acorn.Parser.prototype.parseParenItem">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenItem
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenItem = function (item) {
  return item
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    while (this.type !== tt.parenR) {
first ? first = false : this$1.expect(tt.comma)
if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(tt.parenR, true)) {
  lastIsComma = true
  break
} else if (this$1.type === tt.ellipsis) {
  spreadStart = this$1.start
  exprList.push(this$1.<span class="apidocCodeKeywordSpan">parseParenItem</span>(this$1.parseRest()))
  if (this$1.type === tt.comma) this$1.raise(this$1.start, &#x22;Comma is not permitted after the rest element&#x22;)
  break
} else {
  if (this$1.type === tt.parenL &#x26;&#x26; !innerParenStart) {
    innerParenStart = this$1.start
  }
  exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parsePropertyName" id="apidoc.element.acorn.Parser.prototype.parsePropertyName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyName
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropertyName = function (prop) {
  if (this.options.ecmaVersion &#x3e;= 6) {
    if (this.eat(tt.bracketL)) {
      prop.computed = true
      prop.key = this.parseMaybeAssign()
      this.expect(tt.bracketR)
      return prop.key
    } else {
      prop.computed = false
    }
  }
  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.expect(tt.braceL)
while (!this.eat(tt.braceR)) {
  if (this$1.eat(tt.semi)) continue
  var method = this$1.startNode()
  var isGenerator = this$1.eat(tt.star)
  var isAsync = false
  var isMaybeStatic = this$1.type === tt.name &#x26;&#x26; this$1.value === &#x22;static&#x22;
  this$1.<span class="apidocCodeKeywordSpan">parsePropertyName</span>(method)
  method.static = isMaybeStatic &#x26;&#x26; this$1.type !== tt.parenL
  if (method.static) {
    if (isGenerator) this$1.unexpected()
    isGenerator = this$1.eat(tt.star)
    this$1.parsePropertyName(method)
  }
  if (this$1.options.ecmaVersion &#x3e;= 8 &#x26;&#x26; !isGenerator &#x26;&#x26; !method.computed &#x26;&#x26;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parsePropertyValue" id="apidoc.element.acorn.Parser.prototype.parsePropertyValue">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyValue
        <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
  if ((isGenerator || isAsync) &#x26;&#x26; this.type === tt.colon)
    this.unexpected()

  if (this.eat(tt.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors
)
    prop.kind = &#x22;init&#x22;
  } else if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.type === tt.parenL) {
    if (isPattern) this.unexpected()
    prop.kind = &#x22;init&#x22;
    prop.method = true
    prop.value = this.parseMethod(isGenerator, isAsync)
  } else if (this.options.ecmaVersion &#x3e;= 5 &#x26;&#x26; !prop.computed &#x26;&#x26; prop.key.type === &#x22;Identifier&#x22; &#x26;&#x26;
             (prop.key.name === &#x22;get&#x22; || prop.key.name === &#x22;set&#x22;) &#x26;&#x26;
             (this.type != tt.comma &#x26;&#x26; this.type != tt.braceR)) {
    if (isGenerator || isAsync || isPattern) this.unexpected()
    prop.kind = prop.key.name
    this.parsePropertyName(prop)
    prop.value = this.parseMethod(false)
    var paramCount = prop.kind === &#x22;get&#x22; ? 0 : 1
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start
      if (prop.kind === &#x22;get&#x22;)
        this.raiseRecoverable(start, &#x22;getter should have no params&#x22;)
      else
        this.raiseRecoverable(start, &#x22;setter should have exactly one param&#x22;)
    } else {
      if (prop.kind === &#x22;set&#x22; &#x26;&#x26; prop.value.params[0].type === &#x22;RestElement&#x22;)
        this.raiseRecoverable(prop.value.params[0].start, &#x22;Setter cannot use rest params&#x22;)
    }
  } else if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; !prop.computed &#x26;&#x26; prop.key.type === &#x22;Identifier&#x22;) {
    if (this.keywords.test(prop.key.name) ||
        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||
        (this.inGenerator &#x26;&#x26; prop.key.name == &#x22;yield&#x22;) ||
        (this.inAsync &#x26;&#x26; prop.key.name == &#x22;await&#x22;))
      this.raiseRecoverable(prop.key.start, &#x22;&#x27;&#x22; + prop.key.name + &#x22;&#x27; can not be used as shorthand property&#x22;)
    prop.kind = &#x22;init&#x22;
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
    } else if (this.type === tt.eq &#x26;&#x26; refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign &#x3c; 0)
        refDestructuringErrors.shorthandAssign = this.start
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
    } else {
      prop.value = prop.key
    }
    prop.shorthand = true
  } else this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        prop.key.type === &#x22;Identifier&#x22; &#x26;&#x26; prop.key.name === &#x22;async&#x22; &#x26;&#x26; this$1.type !== tt
.parenL &#x26;&#x26;
        this$1.type !== tt.colon &#x26;&#x26; !this$1.canInsertSemicolon()) {
      isAsync = true
      this$1.parsePropertyName(prop, refDestructuringErrors)
    } else {
      isAsync = false
    }
    this$1.<span class="apidocCodeKeywordSpan">parsePropertyValue</span>(prop, isPattern, isGenerator, isAsync, startPos, startLoc
, refDestructuringErrors)
    this$1.checkPropClash(prop, propHash)
    node.properties.push(this$1.finishNode(prop, &#x22;Property&#x22;))
  }
  return this.finishNode(node, isPattern ? &#x22;ObjectPattern&#x22; : &#x22;ObjectExpression&#x22;)
}

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseRest" id="apidoc.element.acorn.Parser.prototype.parseRest">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseRest
        <span class="apidocSignatureSpan">(allowNonIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseRest = function (allowNonIdent) {
  var node = this.startNode()
  this.next()

  // RestElement inside of a function parameter must be an identifier
  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()
  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()

  return this.finishNode(node, &#x22;RestElement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (first) first = false
else this$1.expect(tt.comma)
if (allowEmpty &#x26;&#x26; this$1.type === tt.comma) {
  elts.push(null)
} else if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(close)) {
  break
} else if (this$1.type === tt.ellipsis) {
  var rest = this$1.<span class="apidocCodeKeywordSpan">parseRest</span>(allowNonIdent)
  this$1.parseBindingListItem(rest)
  elts.push(rest)
  if (this$1.type === tt.comma) this$1.raise(this$1.start, &#x22;Comma is not permitted after the rest element&#x22;)
  this$1.expect(close)
  break
} else {
  var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseReturnStatement" id="apidoc.element.acorn.Parser.prototype.parseReturnStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseReturnStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseReturnStatement = function (node) {
  if (!this.inFunction &#x26;&#x26; !this.options.allowReturnOutsideFunction)
    this.raise(this.start, &#x22;&#x27;return&#x27; outside of function&#x22;)
  this.next()

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null
  else { node.argument = this.parseExpression(); this.semicolon() }
  return this.finishNode(node, &#x22;ReturnStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._function:
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.parseIfStatement(node)
case tt._return: return this.<span class="apidocCodeKeywordSpan">parseReturnStatement</span>(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseSpread" id="apidoc.element.acorn.Parser.prototype.parseSpread">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSpread
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSpread = function (refDestructuringErrors) {
  var node = this.startNode()
  this.next()
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)
  return this.finishNode(node, &#x22;SpreadElement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (allowTrailingComma &#x26;&#x26; this$1.afterTrailingComma(close)) break
  } else first = false

  var elt
  if (allowEmpty &#x26;&#x26; this$1.type === tt.comma)
    elt = null
  else if (this$1.type === tt.ellipsis) {
    elt = this$1.<span class="apidocCodeKeywordSpan">parseSpread</span>(refDestructuringErrors)
    if (refDestructuringErrors &#x26;&#x26; this$1.type === tt.comma &#x26;&#x26; refDestructuringErrors.trailingComma &#x3c; 0)
      refDestructuringErrors.trailingComma = this$1.start
  } else {
    elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
  }
  elts.push(elt)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseStatement" id="apidoc.element.acorn.Parser.prototype.parseStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseStatement
        <span class="apidocSignatureSpan">(declaration, topLevel, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseStatement = function (declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind

  if (this.isLet()) {
    starttype = tt._var
    kind = &#x22;let&#x22;
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case tt._debugger: return this.parseDebuggerStatement(node)
  case tt._do: return this.parseDoStatement(node)
  case tt._for: return this.parseForStatement(node)
  case tt._function:
    if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
    return this.parseFunctionStatement(node, false)
  case tt._class:
    if (!declaration) this.unexpected()
    return this.parseClass(node, true)
  case tt._if: return this.parseIfStatement(node)
  case tt._return: return this.parseReturnStatement(node)
  case tt._switch: return this.parseSwitchStatement(node)
  case tt._throw: return this.parseThrowStatement(node)
  case tt._try: return this.parseTryStatement(node)
  case tt._const: case tt._var:
    kind = kind || this.value
    if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
    return this.parseVarStatement(node, kind)
  case tt._while: return this.parseWhileStatement(node)
  case tt._with: return this.parseWithStatement(node)
  case tt.braceL: return this.parseBlock()
  case tt.semi: return this.parseEmptyStatement(node)
  case tt._export:
  case tt._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level&#x22;)
      if (!this.inModule)
        this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may appear only with &#x27;sourceType: module&#x27;&#x22;)
    }
    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it&#x27;s an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction() &#x26;&#x26; declaration) {
      this.next()
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression()
    if (starttype === tt.name &#x26;&#x26; expr.type === &#x22;Identifier&#x22; &#x26;&#x26; this.eat(tt.colon))
      return this.parseLabeledStatement(node, maybeName, expr)
    else return this.parseExpressionStatement(node, expr)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$1.parseTopLevel = function(node) {
var this$1 = this;

var exports = {}
if (!node.body) node.body = []
while (this.type !== tt.eof) {
  var stmt = this$1.<span class="apidocCodeKeywordSpan">parseStatement</span>(true, true, exports)
  node.body.push(stmt)
}
this.next()
if (this.options.ecmaVersion &#x3e;= 6) {
  node.sourceType = this.options.sourceType
}
return this.finishNode(node, &#x22;Program&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseSubscripts" id="apidoc.element.acorn.Parser.prototype.parseSubscripts">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSubscripts
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion &#x3e;= 8 &#x26;&#x26; base.type === &#x22;Identifier&#x22; &#x26;&#x26; base.name === &#x22;async&#x22; &#x26;&#x26;
      this.lastTokEnd == base.end &#x26;&#x26; !this.canInsertSemicolon()
  for (var computed;;) {
    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc)
      node.object = base
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)
      node.computed = !!computed
      if (computed) this$1.expect(tt.bracketR)
      base = this$1.finishNode(node, &#x22;MemberExpression&#x22;)
    } else if (!noCalls &#x26;&#x26; this$1.eat(tt.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos
      this$1.yieldPos = 0
      this$1.awaitPos = 0
      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion &#x3e;= 8, false, refDestructuringErrors)
      if (maybeAsyncArrow &#x26;&#x26; !this$1.canInsertSemicolon() &#x26;&#x26; this$1.eat(tt.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false)
        this$1.checkYieldAwaitInDefaultParams()
        this$1.yieldPos = oldYieldPos
        this$1.awaitPos = oldAwaitPos
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true)
      this$1.yieldPos = oldYieldPos || this$1.yieldPos
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos
      var node$1 = this$1.startNodeAt(startPos, startLoc)
      node$1.callee = base
      node$1.arguments = exprList
      base = this$1.finishNode(node$1, &#x22;CallExpression&#x22;)
    } else if (this$1.type === tt.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc)
      node$2.tag = base
      node$2.quasi = this$1.parseTemplate()
      base = this$1.finishNode(node$2, &#x22;TaggedTemplateExpression&#x22;)
    } else {
      return base
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseExprAtom(refDestructuringErrors)
  var skipArrowSubscripts = expr.type === &#x22;ArrowFunctionExpression&#x22; &#x26;&#x26; this.input.slice(this.lastTokStart, this
.lastTokEnd) !== &#x22;)&#x22;
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
  var result = this.<span class="apidocCodeKeywordSpan">parseSubscripts</span>(expr, startPos, startLoc)
  if (refDestructuringErrors &#x26;&#x26; result.type === &#x22;MemberExpression&#x22;) {
    if (refDestructuringErrors.parenthesizedAssign &#x3e;= result.start) refDestructuringErrors.parenthesizedAssign = -1
    if (refDestructuringErrors.parenthesizedBind &#x3e;= result.start) refDestructuringErrors.parenthesizedBind = -1
  }
  return result
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseSwitchStatement" id="apidoc.element.acorn.Parser.prototype.parseSwitchStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSwitchStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSwitchStatement = function (node) {
  var this$1 = this;

  this.next()
  node.discriminant = this.parseParenExpression()
  node.cases = []
  this.expect(tt.braceL)
  this.labels.push(switchLabel)
  this.enterLexicalScope()

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur
  for (var sawDefault = false; this.type != tt.braceR;) {
    if (this$1.type === tt._case || this$1.type === tt._default) {
      var isCase = this$1.type === tt._case
      if (cur) this$1.finishNode(cur, &#x22;SwitchCase&#x22;)
      node.cases.push(cur = this$1.startNode())
      cur.consequent = []
      this$1.next()
      if (isCase) {
        cur.test = this$1.parseExpression()
      } else {
        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, &#x22;Multiple default clauses&#x22;)
        sawDefault = true
        cur.test = null
      }
      this$1.expect(tt.colon)
    } else {
      if (!cur) this$1.unexpected()
      cur.consequent.push(this$1.parseStatement(true))
    }
  }
  this.exitLexicalScope()
  if (cur) this.finishNode(cur, &#x22;SwitchCase&#x22;)
  this.next() // Closing brace
  this.labels.pop()
  return this.finishNode(node, &#x22;SwitchStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!declaration &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) this.unexpected()
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.parseIfStatement(node)
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.<span class="apidocCodeKeywordSpan">parseSwitchStatement</span>(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.parseWhileStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTemplate" id="apidoc.element.acorn.Parser.prototype.parseTemplate">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTemplate = function () {
  var this$1 = this;

  var node = this.startNode()
  this.next()
  node.expressions = []
  var curElt = this.parseTemplateElement()
  node.quasis = [curElt]
  while (!curElt.tail) {
    this$1.expect(tt.dollarBraceL)
    node.expressions.push(this$1.parseExpression())
    this$1.expect(tt.braceR)
    node.quasis.push(curElt = this$1.parseTemplateElement())
  }
  this.next()
  return this.finishNode(node, &#x22;TemplateLiteral&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var node$1 = this$1.startNodeAt(startPos, startLoc)
      node$1.callee = base
      node$1.arguments = exprList
      base = this$1.finishNode(node$1, &#x22;CallExpression&#x22;)
    } else if (this$1.type === tt.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc)
      node$2.tag = base
      node$2.quasi = this$1.<span class="apidocCodeKeywordSpan">parseTemplate</span>()
      base = this$1.finishNode(node$2, &#x22;TaggedTemplateExpression&#x22;)
    } else {
      return base
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTemplateElement" id="apidoc.element.acorn.Parser.prototype.parseTemplateElement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplateElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTemplateElement = function () {
  var elem = this.startNode()
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, &#x22;\n&#x22;),
    cooked: this.value
  }
  this.next()
  elem.tail = this.type === tt.backQuote
  return this.finishNode(elem, &#x22;TemplateElement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$3.parseTemplate = function() {
var this$1 = this;

var node = this.startNode()
this.next()
node.expressions = []
var curElt = this.<span class="apidocCodeKeywordSpan">parseTemplateElement</span>()
node.quasis = [curElt]
while (!curElt.tail) {
  this$1.expect(tt.dollarBraceL)
  node.expressions.push(this$1.parseExpression())
  this$1.expect(tt.braceR)
  node.quasis.push(curElt = this$1.parseTemplateElement())
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseThrowStatement" id="apidoc.element.acorn.Parser.prototype.parseThrowStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseThrowStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseThrowStatement = function (node) {
  this.next()
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    this.raise(this.lastTokEnd, &#x22;Illegal newline after throw&#x22;)
  node.argument = this.parseExpression()
  this.semicolon()
  return this.finishNode(node, &#x22;ThrowStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this.parseFunctionStatement(node, false)
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.parseIfStatement(node)
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.<span class="apidocCodeKeywordSpan">parseThrowStatement</span>(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.parseWhileStatement(node)
case tt._with: return this.parseWithStatement(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTopLevel" id="apidoc.element.acorn.Parser.prototype.parseTopLevel">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTopLevel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTopLevel = function (node) {
  var this$1 = this;

  var exports = {}
  if (!node.body) node.body = []
  while (this.type !== tt.eof) {
    var stmt = this$1.parseStatement(true, true, exports)
    node.body.push(stmt)
  }
  this.next()
  if (this.options.ecmaVersion &#x3e;= 6) {
    node.sourceType = this.options.sourceType
  }
  return this.finishNode(node, &#x22;Program&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    plugin(this$1, pluginConfigs[name])
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.startNode()
  this.nextToken()
  return this.<span class="apidocCodeKeywordSpan">parseTopLevel</span>(node)
};

var pp = Parser.prototype

// ## Parser utilities

var literal = /^(?:&#x27;((?:[^&#x27;]|\.)*)&#x27;|&#x22;((?:[^&#x22;]|\.)*)&#x22;|;)/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTryStatement" id="apidoc.element.acorn.Parser.prototype.parseTryStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTryStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTryStatement = function (node) {
  this.next()
  node.block = this.parseBlock()
  node.handler = null
  if (this.type === tt._catch) {
    var clause = this.startNode()
    this.next()
    this.expect(tt.parenL)
    clause.param = this.parseBindingAtom()
    this.enterLexicalScope()
    this.checkLVal(clause.param, &#x22;let&#x22;)
    this.expect(tt.parenR)
    clause.body = this.parseBlock(false)
    this.exitLexicalScope()
    node.handler = this.finishNode(clause, &#x22;CatchClause&#x22;)
  }
  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
  if (!node.handler &#x26;&#x26; !node.finalizer)
    this.raise(node.start, &#x22;Missing catch or finally clause&#x22;)
  return this.finishNode(node, &#x22;TryStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._class:
  if (!declaration) this.unexpected()
  return this.parseClass(node, true)
case tt._if: return this.parseIfStatement(node)
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.<span class="apidocCodeKeywordSpan">parseTryStatement</span>(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.parseWhileStatement(node)
case tt._with: return this.parseWithStatement(node)
case tt.braceL: return this.parseBlock()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseVar" id="apidoc.element.acorn.Parser.prototype.parseVar">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVar
        <span class="apidocSignatureSpan">(node, isFor, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseVar = function (node, isFor, kind) {
  var this$1 = this;

  node.declarations = []
  node.kind = kind
  for (;;) {
    var decl = this$1.startNode()
    this$1.parseVarId(decl, kind)
    if (this$1.eat(tt.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor)
    } else if (kind === &#x22;const&#x22; &#x26;&#x26; !(this$1.type === tt._in || (this$1.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this$1.isContextual(&#x22;of&#x22;)))) {
      this$1.unexpected()
    } else if (decl.id.type != &#x22;Identifier&#x22; &#x26;&#x26; !(isFor &#x26;&#x26; (this$1.type === tt._in || this$1.isContextual(&#x22;of&#x22;)))) {
      this$1.raise(this$1.lastTokEnd, &#x22;Complex binding patterns require an initialization value&#x22;)
    } else {
      decl.init = null
    }
    node.declarations.push(this$1.finishNode(decl, &#x22;VariableDeclarator&#x22;))
    if (!this$1.eat(tt.comma)) break
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.enterLexicalScope()
this.expect(tt.parenL)
if (this.type === tt.semi) return this.parseFor(node, null)
var isLet = this.isLet()
if (this.type === tt._var || this.type === tt._const || isLet) {
  var init$1 = this.startNode(), kind = isLet ? &#x22;let&#x22; : this.value
  this.next()
  this.<span class="apidocCodeKeywordSpan">parseVar</span>(init$1, true, kind)
  this.finishNode(init$1, &#x22;VariableDeclaration&#x22;)
  if ((this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) &#x26;&#x26;
init$1.declarations.length === 1 &#x26;&#x26;
      !(kind !== &#x22;var&#x22; &#x26;&#x26; init$1.declarations[0].init))
    return this.parseForIn(node, init$1)
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseVarId" id="apidoc.element.acorn.Parser.prototype.parseVarId">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarId
        <span class="apidocSignatureSpan">(decl, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom(kind)
  this.checkLVal(decl.id, kind, false)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$1.parseVar = function(node, isFor, kind) {
var this$1 = this;

node.declarations = []
node.kind = kind
for (;;) {
  var decl = this$1.startNode()
  this$1.<span class="apidocCodeKeywordSpan">parseVarId</span>(decl, kind)
  if (this$1.eat(tt.eq)) {
    decl.init = this$1.parseMaybeAssign(isFor)
  } else if (kind === &#x22;const&#x22; &#x26;&#x26; !(this$1.type === tt._in || (this$1.options.ecmaVersion &#x3e;= 6 &#x26;&#x26
; this$1.isContextual(&#x22;of&#x22;)))) {
    this$1.unexpected()
  } else if (decl.id.type != &#x22;Identifier&#x22; &#x26;&#x26; !(isFor &#x26;&#x26; (this$1.type === tt._in || this$1.isContextual
(&#x22;of&#x22;)))) {
    this$1.raise(this$1.lastTokEnd, &#x22;Complex binding patterns require an initialization value&#x22;)
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseVarStatement" id="apidoc.element.acorn.Parser.prototype.parseVarStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarStatement
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseVarStatement = function (node, kind) {
  this.next()
  this.parseVar(node, false, kind)
  this.semicolon()
  return this.finishNode(node, &#x22;VariableDeclaration&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._return: return this.parseReturnStatement(node)
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.<span class="apidocCodeKeywordSpan">parseVarStatement</span>(node, kind)
case tt._while: return this.parseWhileStatement(node)
case tt._with: return this.parseWithStatement(node)
case tt.braceL: return this.parseBlock()
case tt.semi: return this.parseEmptyStatement(node)
case tt._export:
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseWhileStatement" id="apidoc.element.acorn.Parser.prototype.parseWhileStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWhileStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWhileStatement = function (node) {
  this.next()
  node.test = this.parseParenExpression()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, &#x22;WhileStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._switch: return this.parseSwitchStatement(node)
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.<span class="apidocCodeKeywordSpan">parseWhileStatement</span>(node)
case tt._with: return this.parseWithStatement(node)
case tt.braceL: return this.parseBlock()
case tt.semi: return this.parseEmptyStatement(node)
case tt._export:
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseWithStatement" id="apidoc.element.acorn.Parser.prototype.parseWithStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWithStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, &#x22;&#x27;with&#x27; in strict mode&#x22;)
  this.next()
  node.object = this.parseParenExpression()
  node.body = this.parseStatement(false)
  return this.finishNode(node, &#x22;WithStatement&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case tt._throw: return this.parseThrowStatement(node)
case tt._try: return this.parseTryStatement(node)
case tt._const: case tt._var:
  kind = kind || this.value
  if (!declaration &#x26;&#x26; kind != &#x22;var&#x22;) this.unexpected()
  return this.parseVarStatement(node, kind)
case tt._while: return this.parseWhileStatement(node)
case tt._with: return this.<span class="apidocCodeKeywordSpan">parseWithStatement</span>(node)
case tt.braceL: return this.parseBlock()
case tt.semi: return this.parseEmptyStatement(node)
case tt._export:
case tt._import:
  if (!this.options.allowImportExportEverywhere) {
    if (!topLevel)
      this.raise(this.start, &#x22;&#x27;import&#x27; and &#x27;export&#x27; may only appear at the top level&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseYield" id="apidoc.element.acorn.Parser.prototype.parseYield">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseYield
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseYield = function () {
  if (!this.yieldPos) this.yieldPos = this.start

  var node = this.startNode()
  this.next()
  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star &#x26;&#x26; !this.type.startsExpr)) {
    node.delegate = false
    node.argument = null
  } else {
    node.delegate = this.eat(tt.star)
    node.argument = this.parseMaybeAssign()
  }
  return this.finishNode(node, &#x22;YieldExpression&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return expr
}

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
if (this.inGenerator &#x26;&#x26; this.isContextual(&#x22;yield&#x22;)) return this.<span class="apidocCodeKeywordSpan">parseYield
</span>()

var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1
if (refDestructuringErrors) {
  oldParenAssign = refDestructuringErrors.parenthesizedAssign
  oldTrailingComma = refDestructuringErrors.trailingComma
  refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.raise" id="apidoc.element.acorn.Parser.prototype.raise">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raise
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos)
  message += &#x22; (&#x22; + loc.line + &#x22;:&#x22; + loc.column + &#x22;)&#x22;
  var err = new SyntaxError(message)
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos
  throw err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.expect = function(type) {
  this.eat(type) || this.unexpected()
}

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.<span class="apidocCodeKeywordSpan">raise</span>(pos != null ? pos : this.start, &#x22;Unexpected token&#x22;)
}

var DestructuringErrors = function DestructuringErrors() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1
};

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.raiseRecoverable" id="apidoc.element.acorn.Parser.prototype.raiseRecoverable">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raiseRecoverable
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raiseRecoverable = function (pos, message) {
  var loc = getLineInfo(this.input, pos)
  message += &#x22; (&#x22; + loc.line + &#x22;:&#x22; + loc.column + &#x22;)&#x22;
  var err = new SyntaxError(message)
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos
  throw err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var DestructuringErrors = function DestructuringErrors() {
this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1
};

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
if (!refDestructuringErrors) return
if (refDestructuringErrors.trailingComma &#x3e; -1)
  this.<span class="apidocCodeKeywordSpan">raiseRecoverable</span>(refDestructuringErrors.trailingComma, &#x22;Comma is not permitted
 after the rest element&#x22;)
var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind
if (parens &#x3e; -1) this.raiseRecoverable(parens, &#x22;Parenthesized pattern&#x22;)
}

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1
if (!andThrow) return pos &#x3e;= 0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readCodePoint" id="apidoc.element.acorn.Parser.prototype.readCodePoint">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readCodePoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos), code

  if (ch === 123) {
    if (this.options.ecmaVersion &#x3c; 6) this.unexpected()
    var codePos = ++this.pos
    code = this.readHexChar(this.input.indexOf(&#x22;}&#x22;, this.pos) - this.pos)
    ++this.pos
    if (code &#x3e; 0x10FFFF) this.raise(codePos, &#x22;Code point out of bounds&#x22;)
  } else {
    code = this.readHexChar(4)
  }
  return code
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.readEscapedChar = function(inTemplate) {
var ch = this.input.charCodeAt(++this.pos)
++this.pos
switch (ch) {
case 110: return &#x22;\n&#x22; // &#x27;n&#x27; -&#x3e; &#x27;\n&#x27;
case 114: return &#x22;\r&#x22; // &#x27;r&#x27; -&#x3e; &#x27;\r&#x27;
case 120: return String.fromCharCode(this.readHexChar(2)) // &#x27;x&#x27;
case 117: return codePointToString(this.<span class="apidocCodeKeywordSpan">readCodePoint</span>()) // &#x27;u&#x27;
case 116: return &#x22;\t&#x22; // &#x27;t&#x27; -&#x3e; &#x27;\t&#x27;
case 98: return &#x22;\b&#x22; // &#x27;b&#x27; -&#x3e; &#x27;\b&#x27;
case 118: return &#x22;\u000b&#x22; // &#x27;v&#x27; -&#x3e; &#x27;\u000b&#x27;
case 102: return &#x22;\f&#x22; // &#x27;f&#x27; -&#x3e; &#x27;\f&#x27;
case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // &#x27;\r\n&#x27;
case 10: // &#x27; \n&#x27;
  if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readEscapedChar" id="apidoc.element.acorn.Parser.prototype.readEscapedChar">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readEscapedChar
        <span class="apidocSignatureSpan">(inTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos)
  ++this.pos
  switch (ch) {
  case 110: return &#x22;\n&#x22; // &#x27;n&#x27; -&#x3e; &#x27;\n&#x27;
  case 114: return &#x22;\r&#x22; // &#x27;r&#x27; -&#x3e; &#x27;\r&#x27;
  case 120: return String.fromCharCode(this.readHexChar(2)) // &#x27;x&#x27;
  case 117: return codePointToString(this.readCodePoint()) // &#x27;u&#x27;
  case 116: return &#x22;\t&#x22; // &#x27;t&#x27; -&#x3e; &#x27;\t&#x27;
  case 98: return &#x22;\b&#x22; // &#x27;b&#x27; -&#x3e; &#x27;\b&#x27;
  case 118: return &#x22;\u000b&#x22; // &#x27;v&#x27; -&#x3e; &#x27;\u000b&#x27;
  case 102: return &#x22;\f&#x22; // &#x27;f&#x27; -&#x3e; &#x27;\f&#x27;
  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // &#x27;\r\n&#x27;
  case 10: // &#x27; \n&#x27;
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
    return &#x22;&#x22;
  default:
    if (ch &#x3e;= 48 &#x26;&#x26; ch &#x3c;= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]
      var octal = parseInt(octalStr, 8)
      if (octal &#x3e; 255) {
        octalStr = octalStr.slice(0, -1)
        octal = parseInt(octalStr, 8)
      }
      if (octalStr !== &#x22;0&#x22; &#x26;&#x26; (this.strict || inTemplate)) {
        this.raise(this.pos - 2, &#x22;Octal literal in strict mode&#x22;)
      }
      this.pos += octalStr.length - 1
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var out = &#x22;&#x22;, chunkStart = ++this.pos
for (;;) {
  if (this$1.pos &#x3e;= this$1.input.length) this$1.raise(this$1.start, &#x22;Unterminated string constant&#x22;)
  var ch = this$1.input.charCodeAt(this$1.pos)
  if (ch === quote) break
  if (ch === 92) { // &#x27;\&#x27;
    out += this$1.input.slice(chunkStart, this$1.pos)
    out += this$1.<span class="apidocCodeKeywordSpan">readEscapedChar</span>(false)
    chunkStart = this$1.pos
  } else {
    if (isNewLine(ch)) this$1.raise(this$1.start, &#x22;Unterminated string constant&#x22;)
    ++this$1.pos
  }
}
out += this.input.slice(chunkStart, this.pos++)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readHexChar" id="apidoc.element.acorn.Parser.prototype.readHexChar">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readHexChar
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readHexChar = function (len) {
  var codePos = this.pos
  var n = this.readInt(16, len)
  if (n === null) this.raise(codePos, &#x22;Bad character escape sequence&#x22;)
  return n
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

pp$8.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code

  if (ch === 123) {
    if (this.options.ecmaVersion &#x3c; 6) this.unexpected()
    var codePos = ++this.pos
    code = this.<span class="apidocCodeKeywordSpan">readHexChar</span>(this.input.indexOf(&#x22;}&#x22;, this.pos) - this.pos)
    ++this.pos
    if (code &#x3e; 0x10FFFF) this.raise(codePos, &#x22;Code point out of bounds&#x22;)
  } else {
    code = this.readHexChar(4)
  }
  return code
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readInt" id="apidoc.element.acorn.Parser.prototype.readInt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readInt
        <span class="apidocSignatureSpan">(radix, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt = function (radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0
  for (var i = 0, e = len == null ? Infinity : len; i &#x3c; e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val
    if (code &#x3e;= 97) val = code - 97 + 10 // a
    else if (code &#x3e;= 65) val = code - 65 + 10 // A
    else if (code &#x3e;= 48 &#x26;&#x26; code &#x3c;= 57) val = code - 48 // 0-9
    else val = Infinity
    if (val &#x3e;= radix) break
    ++this$1.pos
    total = total * radix + val
  }
  if (this.pos === start || len != null &#x26;&#x26; this.pos - start !== len) return null

  return total
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (this.pos === start || len != null &#x26;&#x26; this.pos - start !== len) return null

  return total
}

pp$8.readRadixNumber = function(radix) {
  this.pos += 2 // 0x
  var val = this.<span class="apidocCodeKeywordSpan">readInt</span>(radix)
  if (val == null) this.raise(this.start + 2, &#x22;Expected number in radix &#x22; + radix)
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, &#x22;Identifier directly after number&#x22;)
  return this.finishToken(tt.num, val)
}

// Read an integer, octal integer, or floating-point number.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readNumber" id="apidoc.element.acorn.Parser.prototype.readNumber">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readNumber
        <span class="apidocSignatureSpan">(startsWithDot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNumber = function (startsWithDot) {
  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48
  if (!startsWithDot &#x26;&#x26; this.readInt(10) === null) this.raise(start, &#x22;Invalid number&#x22;)
  if (octal &#x26;&#x26; this.pos == start + 1) octal = false
  var next = this.input.charCodeAt(this.pos)
  if (next === 46 &#x26;&#x26; !octal) { // &#x27;.&#x27;
    ++this.pos
    this.readInt(10)
    isFloat = true
    next = this.input.charCodeAt(this.pos)
  }
  if ((next === 69 || next === 101) &#x26;&#x26; !octal) { // &#x27;eE&#x27;
    next = this.input.charCodeAt(++this.pos)
    if (next === 43 || next === 45) ++this.pos // &#x27;+-&#x27;
    if (this.readInt(10) === null) this.raise(start, &#x22;Invalid number&#x22;)
    isFloat = true
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, &#x22;Identifier directly after number&#x22;)

  var str = this.input.slice(start, this.pos), val
  if (isFloat) val = parseFloat(str)
  else if (!octal || str.length === 1) val = parseInt(str, 10)
  else if (/[89]/.test(str) || this.strict) this.raise(start, &#x22;Invalid number&#x22;)
  else val = parseInt(str, 8)
  return this.finishToken(tt.num, val)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$8.readToken_dot = function() {
var next = this.input.charCodeAt(this.pos + 1)
if (next &#x3e;= 48 &#x26;&#x26; next &#x3c;= 57) return this.<span class="apidocCodeKeywordSpan">readNumber</span>(true)
var next2 = this.input.charCodeAt(this.pos + 2)
if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; next === 46 &#x26;&#x26; next2 === 46) { // 46 = dot &#x27;.&#x27;
  this.pos += 3
  return this.finishToken(tt.ellipsis)
} else {
  ++this.pos
  return this.finishToken(tt.dot)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readRadixNumber" id="apidoc.element.acorn.Parser.prototype.readRadixNumber">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRadixNumber
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readRadixNumber = function (radix) {
  this.pos += 2 // 0x
  var val = this.readInt(radix)
  if (val == null) this.raise(this.start + 2, &#x22;Expected number in radix &#x22; + radix)
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, &#x22;Identifier directly after number&#x22;)
  return this.finishToken(tt.num, val)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 96: // &#x27;`&#x27;
  if (this.options.ecmaVersion &#x3c; 6) break
  ++this.pos
  return this.finishToken(tt.backQuote)

case 48: // &#x27;0&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === 120 || next === 88) return this.<span class="apidocCodeKeywordSpan">readRadixNumber</span>(16) // &#x27;0x&#x27;, &#
x27;0X&#x27; - hex number
  if (this.options.ecmaVersion &#x3e;= 6) {
    if (next === 111 || next === 79) return this.readRadixNumber(8) // &#x27;0o&#x27;, &#x27;0O&#x27; - octal number
    if (next === 98 || next === 66) return this.readRadixNumber(2) // &#x27;0b&#x27;, &#x27;0B&#x27; - binary number
  }
  // Anything else beginning with a digit is an integer, octal
  // number, or float.
case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readRegexp" id="apidoc.element.acorn.Parser.prototype.readRegexp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRegexp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readRegexp = function () {
  var this$1 = this;

  var escaped, inClass, start = this.pos
  for (;;) {
    if (this$1.pos &#x3e;= this$1.input.length) this$1.raise(start, &#x22;Unterminated regular expression&#x22;)
    var ch = this$1.input.charAt(this$1.pos)
    if (lineBreak.test(ch)) this$1.raise(start, &#x22;Unterminated regular expression&#x22;)
    if (!escaped) {
      if (ch === &#x22;[&#x22;) inClass = true
      else if (ch === &#x22;]&#x22; &#x26;&#x26; inClass) inClass = false
      else if (ch === &#x22;/&#x22; &#x26;&#x26; !inClass) break
      escaped = ch === &#x22;\\&#x22;
    } else escaped = false
    ++this$1.pos
  }
  var content = this.input.slice(start, this.pos)
  ++this.pos
  // Need to use `readWord1` because &#x27;\uXXXX&#x27; sequences are allowed
  // here (don&#x27;t ask).
  var mods = this.readWord1()
  var tmp = content, tmpFlags = &#x22;&#x22;
  if (mods) {
    var validFlags = /^[gim]*$/
    if (this.options.ecmaVersion &#x3e;= 6) validFlags = /^[gimuy]*$/
    if (!validFlags.test(mods)) this.raise(start, &#x22;Invalid regular expression flag&#x22;)
    if (mods.indexOf(&#x22;u&#x22;) &#x3e;= 0) {
      if (regexpUnicodeSupport) {
        tmpFlags = &#x22;u&#x22;
      } else {
        // Replace each astral symbol and every Unicode escape sequence that
        // possibly represents an astral symbol or a paired surrogate with a
        // single ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        // Note: replacing with the ASCII symbol `x` might cause false
        // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
        // perfectly valid pattern that is equivalent to `[a-b]`, but it would
        // be replaced by `[x-b]` which throws an error.
        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
          code = Number(&#x22;0x&#x22; + code)
          if (code &#x3e; 0x10FFFF) this$1.raise(start + offset + 3, &#x22;Code point out of bounds&#x22;)
          return &#x22;x&#x22;
        })
        tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, &#x22;x&#x22;)
        tmpFlags = tmpFlags.replace(&#x22;u&#x22;, &#x22;&#x22;)
      }
    }
  }
  // Detect invalid regular expressions.
  var value = null
  // Rhino&#x27;s regular expression parser is flaky and throws uncatchable exceptions,
  // so don&#x27;t do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, tmpFlags, start, this)
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn&#x27;t support the flags it uses.
    value = tryCreateRegexp(content, mods)
  }
  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ++this.pos
  return this.finishToken(tt.dot)
}
}

pp$8.readToken_slash = function() { // &#x27;/&#x27;
var next = this.input.charCodeAt(this.pos + 1)
if (this.exprAllowed) { ++this.pos; return this.<span class="apidocCodeKeywordSpan">readRegexp</span>() }
if (next === 61) return this.finishOp(tt.assign, 2)
return this.finishOp(tt.slash, 1)
}

pp$8.readToken_mult_modulo_exp = function(code) { // &#x27;%*&#x27;
var next = this.input.charCodeAt(this.pos + 1)
var size = 1
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readString" id="apidoc.element.acorn.Parser.prototype.readString">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readString
        <span class="apidocSignatureSpan">(quote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (quote) {
  var this$1 = this;

  var out = &#x22;&#x22;, chunkStart = ++this.pos
  for (;;) {
    if (this$1.pos &#x3e;= this$1.input.length) this$1.raise(this$1.start, &#x22;Unterminated string constant&#x22;)
    var ch = this$1.input.charCodeAt(this$1.pos)
    if (ch === quote) break
    if (ch === 92) { // &#x27;\&#x27;
      out += this$1.input.slice(chunkStart, this$1.pos)
      out += this$1.readEscapedChar(false)
      chunkStart = this$1.pos
    } else {
      if (isNewLine(ch)) this$1.raise(this$1.start, &#x22;Unterminated string constant&#x22;)
      ++this$1.pos
    }
  }
  out += this.input.slice(chunkStart, this.pos++)
  return this.finishToken(tt.string, out)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Anything else beginning with a digit is an integer, octal
  // number, or float.
case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
  return this.readNumber(false)

  // Quotes produce strings.
case 34: case 39: // &#x27;&#x22;&#x27;, &#x22;&#x27;&#x22;
  return this.<span class="apidocCodeKeywordSpan">readString</span>(code)

  // Operators are parsed inline in tiny state machines. &#x27;=&#x27; (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

case 47: // &#x27;/&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readTmplToken" id="apidoc.element.acorn.Parser.prototype.readTmplToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readTmplToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTmplToken = function () {
  var this$1 = this;

  var out = &#x22;&#x22;, chunkStart = this.pos
  for (;;) {
    if (this$1.pos &#x3e;= this$1.input.length) this$1.raise(this$1.start, &#x22;Unterminated template&#x22;)
    var ch = this$1.input.charCodeAt(this$1.pos)
    if (ch === 96 || ch === 36 &#x26;&#x26; this$1.input.charCodeAt(this$1.pos + 1) === 123) { // &#x27;`&#x27;, &#x27;${&#x27;
      if (this$1.pos === this$1.start &#x26;&#x26; this$1.type === tt.template) {
        if (ch === 36) {
          this$1.pos += 2
          return this$1.finishToken(tt.dollarBraceL)
        } else {
          ++this$1.pos
          return this$1.finishToken(tt.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos)
      return this$1.finishToken(tt.template, out)
    }
    if (ch === 92) { // &#x27;\&#x27;
      out += this$1.input.slice(chunkStart, this$1.pos)
      out += this$1.readEscapedChar(true)
      chunkStart = this$1.pos
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos)
      ++this$1.pos
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos
      case 10:
        out += &#x22;\n&#x22;
        break
      default:
        out += String.fromCharCode(ch)
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine
        this$1.lineStart = this$1.pos
      }
      chunkStart = this$1.pos
    } else {
      ++this$1.pos
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var types = {
  b_stat: new TokContext(&#x22;{&#x22;, false),
  b_expr: new TokContext(&#x22;{&#x22;, true),
  b_tmpl: new TokContext(&#x22;${&#x22;, true),
  p_stat: new TokContext(&#x22;(&#x22;, false),
  p_expr: new TokContext(&#x22;(&#x22;, true),
  q_tmpl: new TokContext(&#x22;`&#x22;, true, true, function (p) { return p.<span class="apidocCodeKeywordSpan">readTmplToken</span
>(); }),
  f_expr: new TokContext(&#x22;function&#x22;, true),
  f_expr_gen: new TokContext(&#x22;function&#x22;, true, false, null, true),
  f_gen: new TokContext(&#x22;function&#x22;, false, false, null, true)
}

var pp$7 = Parser.prototype
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken" id="apidoc.element.acorn.Parser.prototype.readToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken = function (code) {
  // Identifier or keyword. &#x27;\uXXXX&#x27; sequences are allowed in
  // identifiers, so &#x27;\&#x27; also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &#x3e;= 6) || code === 92 /* &#x27;\&#x27; */)
    return this.readWord()

  return this.getTokenFromCode(code)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!curContext || !curContext.preserveSpace) this.skipSpace()

this.start = this.pos
if (this.options.locations) this.startLoc = this.curPosition()
if (this.pos &#x3e;= this.input.length) return this.finishToken(tt.eof)

if (curContext.override) return curContext.override(this)
else this.<span class="apidocCodeKeywordSpan">readToken</span>(this.fullCharCodeAtPos())
}

pp$8.readToken = function(code) {
// Identifier or keyword. &#x27;\uXXXX&#x27; sequences are allowed in
// identifiers, so &#x27;\&#x27; also dispatches to that.
if (isIdentifierStart(code, this.options.ecmaVersion &#x3e;= 6) || code === 92 /* &#x27;\&#x27; */)
  return this.readWord()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_caret" id="apidoc.element.acorn.Parser.prototype.readToken_caret">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_caret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_caret = function () { // &#x27;^&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.bitwiseXOR, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 37: case 42: // &#x27;%*&#x27;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &#x27;|&#x26;&#x27;
  return this.readToken_pipe_amp(code)

case 94: // &#x27;^&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_caret</span>()

case 43: case 45: // &#x27;+-&#x27;
  return this.readToken_plus_min(code)

case 60: case 62: // &#x27;&#x3c;&#x3e;&#x27;
  return this.readToken_lt_gt(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_dot" id="apidoc.element.acorn.Parser.prototype.readToken_dot">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1)
  if (next &#x3e;= 48 &#x26;&#x26; next &#x3c;= 57) return this.readNumber(true)
  var next2 = this.input.charCodeAt(this.pos + 2)
  if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; next === 46 &#x26;&#x26; next2 === 46) { // 46 = dot &#x27;.&#x27;
    this.pos += 3
    return this.finishToken(tt.ellipsis)
  } else {
    ++this.pos
    return this.finishToken(tt.dot)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

pp$8.getTokenFromCode = function(code) {
switch (code) {
  // The interpretation of a dot depends on whether it is followed
  // by a digit or another two dots.
case 46: // &#x27;.&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_dot</span>()

  // Punctuation tokens.
case 40: ++this.pos; return this.finishToken(tt.parenL)
case 41: ++this.pos; return this.finishToken(tt.parenR)
case 59: ++this.pos; return this.finishToken(tt.semi)
case 44: ++this.pos; return this.finishToken(tt.comma)
case 91: ++this.pos; return this.finishToken(tt.bracketL)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_eq_excl" id="apidoc.element.acorn.Parser.prototype.readToken_eq_excl">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_eq_excl
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_eq_excl = function (code) { // &#x27;=!&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
  if (code === 61 &#x26;&#x26; next === 62 &#x26;&#x26; this.options.ecmaVersion &#x3e;= 6) { // &#x27;=&#x3e;&#x27;
    this.pos += 2
    return this.finishToken(tt.arrow)
  }
  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case 43: case 45: // &#x27;+-&#x27;
    return this.readToken_plus_min(code)

  case 60: case 62: // &#x27;&#x3c;&#x3e;&#x27;
    return this.readToken_lt_gt(code)

  case 61: case 33: // &#x27;=!&#x27;
    return this.<span class="apidocCodeKeywordSpan">readToken_eq_excl</span>(code)

  case 126: // &#x27;~&#x27;
    return this.finishOp(tt.prefix, 1)
  }

  this.raise(this.pos, &#x22;Unexpected character &#x27;&#x22; + codePointToString(code) + &#x22;&#x27;&#x22;)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_lt_gt" id="apidoc.element.acorn.Parser.prototype.readToken_lt_gt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_lt_gt
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_lt_gt = function (code) { // &#x27;&#x3c;&#x3e;&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  var size = 1
  if (next === code) {
    size = code === 62 &#x26;&#x26; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
    return this.finishOp(tt.bitShift, size)
  }
  if (next == 33 &#x26;&#x26; code == 60 &#x26;&#x26; this.input.charCodeAt(this.pos + 2) == 45 &#x26;&#x26;
      this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected()
    // `&#x3c;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4)
    this.skipSpace()
    return this.nextToken()
  }
  if (next === 61) size = 2
  return this.finishOp(tt.relational, size)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 94: // &#x27;^&#x27;
  return this.readToken_caret()

case 43: case 45: // &#x27;+-&#x27;
  return this.readToken_plus_min(code)

case 60: case 62: // &#x27;&#x3c;&#x3e;&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_lt_gt</span>(code)

case 61: case 33: // &#x27;=!&#x27;
  return this.readToken_eq_excl(code)

case 126: // &#x27;~&#x27;
  return this.finishOp(tt.prefix, 1)
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_mult_modulo_exp" id="apidoc.element.acorn.Parser.prototype.readToken_mult_modulo_exp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_mult_modulo_exp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_mult_modulo_exp = function (code) { // &#x27;%*&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  var size = 1
  var tokentype = code === 42 ? tt.star : tt.modulo

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion &#x3e;= 7 &#x26;&#x26; next === 42) {
    ++size
    tokentype = tt.starstar
    next = this.input.charCodeAt(this.pos + 2)
  }

  if (next === 61) return this.finishOp(tt.assign, size + 1)
  return this.finishOp(tokentype, size)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

case 47: // &#x27;/&#x27;
  return this.readToken_slash()

case 37: case 42: // &#x27;%*&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_mult_modulo_exp</span>(code)

case 124: case 38: // &#x27;|&#x26;&#x27;
  return this.readToken_pipe_amp(code)

case 94: // &#x27;^&#x27;
  return this.readToken_caret()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_pipe_amp" id="apidoc.element.acorn.Parser.prototype.readToken_pipe_amp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_pipe_amp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_pipe_amp = function (code) { // &#x27;|&#x26;&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 47: // &#x27;/&#x27;
  return this.readToken_slash()

case 37: case 42: // &#x27;%*&#x27;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &#x27;|&#x26;&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_pipe_amp</span>(code)

case 94: // &#x27;^&#x27;
  return this.readToken_caret()

case 43: case 45: // &#x27;+-&#x27;
  return this.readToken_plus_min(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_plus_min" id="apidoc.element.acorn.Parser.prototype.readToken_plus_min">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_plus_min
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_plus_min = function (code) { // &#x27;+-&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === code) {
    if (next == 45 &#x26;&#x26; this.input.charCodeAt(this.pos + 2) == 62 &#x26;&#x26;
        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `--&#x3e;` line comment
      this.skipLineComment(3)
      this.skipSpace()
      return this.nextToken()
    }
    return this.finishOp(tt.incDec, 2)
  }
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.plusMin, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 124: case 38: // &#x27;|&#x26;&#x27;
  return this.readToken_pipe_amp(code)

case 94: // &#x27;^&#x27;
  return this.readToken_caret()

case 43: case 45: // &#x27;+-&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_plus_min</span>(code)

case 60: case 62: // &#x27;&#x3c;&#x3e;&#x27;
  return this.readToken_lt_gt(code)

case 61: case 33: // &#x27;=!&#x27;
  return this.readToken_eq_excl(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_slash" id="apidoc.element.acorn.Parser.prototype.readToken_slash">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_slash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_slash = function () { // &#x27;/&#x27;
  var next = this.input.charCodeAt(this.pos + 1)
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.slash, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // Operators are parsed inline in tiny state machines. &#x27;=&#x27; (61) is
  // often referred to. `finishOp` simply skips the amount of
  // characters it is given as second argument, and returns a token
  // of the type given by its first argument.

case 47: // &#x27;/&#x27;
  return this.<span class="apidocCodeKeywordSpan">readToken_slash</span>()

case 37: case 42: // &#x27;%*&#x27;
  return this.readToken_mult_modulo_exp(code)

case 124: case 38: // &#x27;|&#x26;&#x27;
  return this.readToken_pipe_amp(code)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readWord" id="apidoc.element.acorn.Parser.prototype.readWord">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readWord = function () {
  var word = this.readWord1()
  var type = tt.name
  if (this.keywords.test(word)) {
    if (this.containsEsc) this.raiseRecoverable(this.start, &#x22;Escape sequence in keyword &#x22; + word)
    type = keywordTypes[word]
  }
  return this.finishToken(type, word)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else this.readToken(this.fullCharCodeAtPos())
}

pp$8.readToken = function(code) {
// Identifier or keyword. &#x27;\uXXXX&#x27; sequences are allowed in
// identifiers, so &#x27;\&#x27; also dispatches to that.
if (isIdentifierStart(code, this.options.ecmaVersion &#x3e;= 6) || code === 92 /* &#x27;\&#x27; */)
  return this.<span class="apidocCodeKeywordSpan">readWord</span>()

return this.getTokenFromCode(code)
}

pp$8.fullCharCodeAtPos = function() {
var code = this.input.charCodeAt(this.pos)
if (code &#x3c;= 0xd7ff || code &#x3e;= 0xe000) return code
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readWord1" id="apidoc.element.acorn.Parser.prototype.readWord1">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readWord1 = function () {
  var this$1 = this;

  this.containsEsc = false
  var word = &#x22;&#x22;, first = true, chunkStart = this.pos
  var astral = this.options.ecmaVersion &#x3e;= 6
  while (this.pos &#x3c; this.input.length) {
    var ch = this$1.fullCharCodeAtPos()
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch &#x3c;= 0xffff ? 1 : 2
    } else if (ch === 92) { // &#x22;\&#x22;
      this$1.containsEsc = true
      word += this$1.input.slice(chunkStart, this$1.pos)
      var escStart = this$1.pos
      if (this$1.input.charCodeAt(++this$1.pos) != 117) // &#x22;u&#x22;
        this$1.raise(this$1.pos, &#x22;Expecting Unicode escape sequence \\uXXXX&#x22;)
      ++this$1.pos
      var esc = this$1.readCodePoint()
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        this$1.raise(escStart, &#x22;Invalid Unicode escape&#x22;)
      word += codePointToString(esc)
      chunkStart = this$1.pos
    } else {
      break
    }
    first = false
  }
  return word + this.input.slice(chunkStart, this.pos)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else escaped = false
  ++this$1.pos
}
var content = this.input.slice(start, this.pos)
++this.pos
// Need to use `readWord1` because &#x27;\uXXXX&#x27; sequences are allowed
// here (don&#x27;t ask).
var mods = this.<span class="apidocCodeKeywordSpan">readWord1</span>()
var tmp = content, tmpFlags = &#x22;&#x22;
if (mods) {
  var validFlags = /^[gim]*$/
  if (this.options.ecmaVersion &#x3e;= 6) validFlags = /^[gimuy]*$/
  if (!validFlags.test(mods)) this.raise(start, &#x22;Invalid regular expression flag&#x22;)
  if (mods.indexOf(&#x22;u&#x22;) &#x3e;= 0) {
    if (regexpUnicodeSupport) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.semicolon" id="apidoc.element.acorn.Parser.prototype.semicolon">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">semicolon = function () {
  if (!this.eat(tt.semi) &#x26;&#x26; !this.insertSemicolon()) this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var isBreak = keyword == &#x22;break&#x22;
this.next()
if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
else if (this.type !== tt.name) this.unexpected()
else {
  node.label = this.parseIdent()
  this.<span class="apidocCodeKeywordSpan">semicolon</span>()
}

// Verify that there is an actual destination to break or
// continue to.
var i = 0
for (; i &#x3c; this.labels.length; ++i) {
  var lab = this$1.labels[i]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.shouldParseExportStatement" id="apidoc.element.acorn.Parser.prototype.shouldParseExportStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>shouldParseExportStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldParseExportStatement = function () {
  return this.type.keyword === &#x22;var&#x22; ||
    this.type.keyword === &#x22;const&#x22; ||
    this.type.keyword === &#x22;class&#x22; ||
    this.type.keyword === &#x22;function&#x22; ||
    this.isLet() ||
    this.isAsyncFunction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    node.declaration = this.parseMaybeAssign()
    this.semicolon()
  }
  return this.finishNode(node, &#x22;ExportDefaultDeclaration&#x22;)
}
// export var|const|let|function|class ...
if (this.<span class="apidocCodeKeywordSpan">shouldParseExportStatement</span>()) {
  node.declaration = this.parseStatement(true)
  if (node.declaration.type === &#x22;VariableDeclaration&#x22;)
    this.checkVariableExport(exports, node.declaration.declarations)
  else
    this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)
  node.specifiers = []
  node.source = null
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.skipBlockComment" id="apidoc.element.acorn.Parser.prototype.skipBlockComment">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipBlockComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipBlockComment = function () {
  var this$1 = this;

  var startLoc = this.options.onComment &#x26;&#x26; this.curPosition()
  var start = this.pos, end = this.input.indexOf(&#x22;*/&#x22;, this.pos += 2)
  if (end === -1) this.raise(this.pos - 2, &#x22;Unterminated comment&#x22;)
  this.pos = end + 2
  if (this.options.locations) {
    lineBreakG.lastIndex = start
    var match
    while ((match = lineBreakG.exec(this.input)) &#x26;&#x26; match.index &#x3c; this.pos) {
      ++this$1.curLine
      this$1.lineStart = match.index + match[0].length
    }
  }
  if (this.options.onComment)
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ++this$1.curLine
    this$1.lineStart = this$1.pos
  }
  break
case 47: // &#x27;/&#x27;
  switch (this$1.input.charCodeAt(this$1.pos + 1)) {
  case 42: // &#x27;*&#x27;
    this$1.<span class="apidocCodeKeywordSpan">skipBlockComment</span>()
    break
  case 47:
    this$1.skipLineComment(2)
    break
  default:
    break loop
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.skipLineComment" id="apidoc.element.acorn.Parser.prototype.skipLineComment">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipLineComment
        <span class="apidocSignatureSpan">(startSkip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLineComment = function (startSkip) {
  var this$1 = this;

  var start = this.pos
  var startLoc = this.options.onComment &#x26;&#x26; this.curPosition()
  var ch = this.input.charCodeAt(this.pos += startSkip)
  while (this.pos &#x3c; this.input.length &#x26;&#x26; ch !== 10 &#x26;&#x26; ch !== 13 &#x26;&#x26; ch !== 8232 &#x26;&#x26; ch !== 8233) {
    ++this$1.pos
    ch = this$1.input.charCodeAt(this$1.pos)
  }
  if (this.options.onComment)
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0
  // Labels in scope.
  this.labels = []

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &#x26;&#x26; options.allowHashBang &#x26;&#x26; this.input.slice(0, 2) === &#x22;#!&#x22;)
    this.<span class="apidocCodeKeywordSpan">skipLineComment</span>(2)

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = []
  this.enterFunctionScope()
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.skipSpace" id="apidoc.element.acorn.Parser.prototype.skipSpace">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipSpace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipSpace = function () {
  var this$1 = this;

  loop: while (this.pos &#x3c; this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos)
    switch (ch) {
    case 32: case 160: // &#x27; &#x27;
      ++this$1.pos
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos
      }
    case 10: case 8232: case 8233:
      ++this$1.pos
      if (this$1.options.locations) {
        ++this$1.curLine
        this$1.lineStart = this$1.pos
      }
      break
    case 47: // &#x27;/&#x27;
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // &#x27;*&#x27;
        this$1.skipBlockComment()
        break
      case 47:
        this$1.skipLineComment(2)
        break
      default:
        break loop
      }
      break
    default:
      if (ch &#x3e; 8 &#x26;&#x26; ch &#x3c; 14 || ch &#x3e;= 5760 &#x26;&#x26; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos
      } else {
        break loop
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Read a single token, updating the parser object&#x27;s token-related
// properties.

pp$8.nextToken = function() {
var curContext = this.curContext()
if (!curContext || !curContext.preserveSpace) this.<span class="apidocCodeKeywordSpan">skipSpace</span>()

this.start = this.pos
if (this.options.locations) this.startLoc = this.curPosition()
if (this.pos &#x3e;= this.input.length) return this.finishToken(tt.eof)

if (curContext.override) return curContext.override(this)
else this.readToken(this.fullCharCodeAtPos())
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.startNode" id="apidoc.element.acorn.Parser.prototype.startNode">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startNode = function () {
  return new Node(this, this.start, this.startLoc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var plugin = plugins[name]
    if (!plugin) throw new Error(&#x22;Plugin &#x27;&#x22; + name + &#x22;&#x27; not found&#x22;)
    plugin(this$1, pluginConfigs[name])
  }
};

Parser.prototype.parse = function parse () {
  var node = this.options.program || this.<span class="apidocCodeKeywordSpan">startNode</span>()
  this.nextToken()
  return this.parseTopLevel(node)
};

var pp = Parser.prototype

// ## Parser utilities
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.startNodeAt" id="apidoc.element.acorn.Parser.prototype.startNodeAt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNodeAt
        <span class="apidocSignatureSpan">(pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom()
  if (this.options.ecmaVersion &#x3c; 6 || !this.eat(tt.eq)) return left
  var node = this.<span class="apidocCodeKeywordSpan">startNodeAt</span>(startPos, startLoc)
  node.left = left
  node.right = this.parseMaybeAssign()
  return this.finishNode(node, &#x22;AssignmentPattern&#x22;)
}

// Verify that a node is an lval — something that can be assigned
// to.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.strictDirective" id="apidoc.element.acorn.Parser.prototype.strictDirective">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>strictDirective
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strictDirective = function (start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start
    start += skipWhiteSpace.exec(this$1.input)[0].length
    var match = literal.exec(this$1.input.slice(start))
    if (!match) return false
    if ((match[1] || match[2]) == &#x22;use strict&#x22;) return true
    start += match[0].length
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// context to predict whether a regular expression is allowed in a
// given position.
this.context = this.initialContext()
this.exprAllowed = true

// Figure out if it&#x27;s a module code.
this.inModule = options.sourceType === &#x22;module&#x22;
this.strict = this.inModule || this.<span class="apidocCodeKeywordSpan">strictDirective</span>(this.pos)

// Used to signify the start of a potential arrow function
this.potentialArrowAt = -1

// Flags to track whether we are in a function, a generator, an async function.
this.inFunction = this.inGenerator = this.inAsync = false
// Positions to delayed-check that yield/await does not exist in default parameters.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.toAssignable" id="apidoc.element.acorn.Parser.prototype.toAssignable">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignable
        <span class="apidocSignatureSpan">(node, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAssignable = function (node, isBinding) {
  var this$1 = this;

  if (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; node) {
    switch (node.type) {
    case &#x22;Identifier&#x22;:
      if (this.inAsync &#x26;&#x26; node.name === &#x22;await&#x22;)
        this.raise(node.start, &#x22;Can not use &#x27;await&#x27; as identifier inside an async function&#x22;)
      break

    case &#x22;ObjectPattern&#x22;:
    case &#x22;ArrayPattern&#x22;:
      break

    case &#x22;ObjectExpression&#x22;:
      node.type = &#x22;ObjectPattern&#x22;
      for (var i = 0; i &#x3c; node.properties.length; i++) {
        var prop = node.properties[i]
        if (prop.kind !== &#x22;init&#x22;) this$1.raise(prop.key.start, &#x22;Object pattern can&#x27;t contain getter or setter&#x22;)
        this$1.toAssignable(prop.value, isBinding)
      }
      break

    case &#x22;ArrayExpression&#x22;:
      node.type = &#x22;ArrayPattern&#x22;
      this.toAssignableList(node.elements, isBinding)
      break

    case &#x22;AssignmentExpression&#x22;:
      if (node.operator === &#x22;=&#x22;) {
        node.type = &#x22;AssignmentPattern&#x22;
        delete node.operator
        this.toAssignable(node.left, isBinding)
        // falls through to AssignmentPattern
      } else {
        this.raise(node.left.end, &#x22;Only &#x27;=&#x27; operator can be used for specifying default value.&#x22;)
        break
      }

    case &#x22;AssignmentPattern&#x22;:
      break

    case &#x22;ParenthesizedExpression&#x22;:
      node.expression = this.toAssignable(node.expression, isBinding)
      break

    case &#x22;MemberExpression&#x22;:
      if (!isBinding) break

    default:
      this.raise(node.start, &#x22;Assigning to rvalue&#x22;)
    }
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      !(kind !== &#x22;var&#x22; &#x26;&#x26; init$1.declarations[0].init))
    return this.parseForIn(node, init$1)
  return this.parseFor(node, init$1)
}
var refDestructuringErrors = new DestructuringErrors
var init = this.parseExpression(true, refDestructuringErrors)
if (this.type === tt._in || (this.options.ecmaVersion &#x3e;= 6 &#x26;&#x26; this.isContextual(&#x22;of&#x22;))) {
  this.<span class="apidocCodeKeywordSpan">toAssignable</span>(init)
  this.checkLVal(init)
  this.checkPatternErrors(refDestructuringErrors, true)
  return this.parseForIn(node, init)
} else {
  this.checkExpressionErrors(refDestructuringErrors, true)
}
return this.parseFor(node, init)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.toAssignableList" id="apidoc.element.acorn.Parser.prototype.toAssignableList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignableList
        <span class="apidocSignatureSpan">(exprList, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAssignableList = function (exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length
  if (end) {
    var last = exprList[end - 1]
    if (last &#x26;&#x26; last.type == &#x22;RestElement&#x22;) {
      --end
    } else if (last &#x26;&#x26; last.type == &#x22;SpreadElement&#x22;) {
      last.type = &#x22;RestElement&#x22;
      var arg = last.argument
      this.toAssignable(arg, isBinding)
      if (arg.type !== &#x22;Identifier&#x22; &#x26;&#x26; arg.type !== &#x22;MemberExpression&#x22; &#x26;&#x26; arg.type !== &#x22;ArrayPattern&#x22;)
        this.unexpected(arg.start)
      --end
    }

    if (isBinding &#x26;&#x26; last &#x26;&#x26; last.type === &#x22;RestElement&#x22; &#x26;&#x26; last.argument.type !== &#x22;Identifier&#x22;)
      this.unexpected(last.argument.start)
  }
  for (var i = 0; i &#x3c; end; i++) {
    var elt = exprList[i]
    if (elt) this$1.toAssignable(elt, isBinding)
  }
  return exprList
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (prop.kind !== &#x22;init&#x22;) this$1.raise(prop.key.start, &#x22;Object pattern can&#x27;t contain getter or setter&#x22
;)
    this$1.toAssignable(prop.value, isBinding)
  }
  break

case &#x22;ArrayExpression&#x22;:
  node.type = &#x22;ArrayPattern&#x22;
  this.<span class="apidocCodeKeywordSpan">toAssignableList</span>(node.elements, isBinding)
  break

case &#x22;AssignmentExpression&#x22;:
  if (node.operator === &#x22;=&#x22;) {
    node.type = &#x22;AssignmentPattern&#x22;
    delete node.operator
    this.toAssignable(node.left, isBinding)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.unexpected" id="apidoc.element.acorn.Parser.prototype.unexpected">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>unexpected
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, &#x22;Unexpected token&#x22;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp.eatContextual = function(name) {
return this.value === name &#x26;&#x26; this.eat(tt.name)
}

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
if (!this.eatContextual(name)) this.<span class="apidocCodeKeywordSpan">unexpected</span>()
}

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
return this.type === tt.eof ||
  this.type === tt.braceR ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.updateContext" id="apidoc.element.acorn.Parser.prototype.updateContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>updateContext
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateContext = function (prevType) {
  var update, type = this.type
  if (type.keyword &#x26;&#x26; prevType == tt.dot)
    this.exprAllowed = false
  else if (update = type.updateContext)
    update.call(this, prevType)
  else
    this.exprAllowed = type.beforeExpr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
pp$8.finishToken = function(type, val) {
  this.end = this.pos
  if (this.options.locations) this.endLoc = this.curPosition()
  var prevType = this.type
  this.type = type
  this.value = val

  this.<span class="apidocCodeKeywordSpan">updateContext</span>(prevType)
}

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Position" id="apidoc.module.acorn.Position">module acorn.Position</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Position.Position" id="apidoc.element.acorn.Position.Position">
        function <span class="apidocSignatureSpan">acorn.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line
  this.column = col
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Position.prototype" id="apidoc.module.acorn.Position.prototype">module acorn.Position.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Position.prototype.offset" id="apidoc.element.acorn.Position.prototype.offset">
        function <span class="apidocSignatureSpan">acorn.Position.prototype.</span>offset
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function offset(n) {
  return new Position(this.line, this.column + n)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
