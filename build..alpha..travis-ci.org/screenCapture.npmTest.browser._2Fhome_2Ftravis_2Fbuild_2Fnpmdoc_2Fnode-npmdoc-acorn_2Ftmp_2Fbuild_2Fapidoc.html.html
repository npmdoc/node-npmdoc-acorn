<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/ternjs/acorn">acorn (v5.0.3)</a>
</h1>
<h4>ECMAScript parser</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn">module acorn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Node">
            function <span class="apidocSignatureSpan">acorn.</span>Node
            <span class="apidocSignatureSpan">(parser, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser">
            function <span class="apidocSignatureSpan">acorn.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Position">
            function <span class="apidocSignatureSpan">acorn.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.SourceLocation">
            function <span class="apidocSignatureSpan">acorn.</span>SourceLocation
            <span class="apidocSignatureSpan">(p, start, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.TokContext">
            function <span class="apidocSignatureSpan">acorn.</span>TokContext
            <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Token">
            function <span class="apidocSignatureSpan">acorn.</span>Token
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.TokenType">
            function <span class="apidocSignatureSpan">acorn.</span>TokenType
            <span class="apidocSignatureSpan">(label, conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.addLooseExports">
            function <span class="apidocSignatureSpan">acorn.</span>addLooseExports
            <span class="apidocSignatureSpan">(parse, Parser, plugins)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.getLineInfo">
            function <span class="apidocSignatureSpan">acorn.</span>getLineInfo
            <span class="apidocSignatureSpan">(input, offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.isIdentifierChar">
            function <span class="apidocSignatureSpan">acorn.</span>isIdentifierChar
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.isIdentifierStart">
            function <span class="apidocSignatureSpan">acorn.</span>isIdentifierStart
            <span class="apidocSignatureSpan">(code, astral)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.isNewLine">
            function <span class="apidocSignatureSpan">acorn.</span>isNewLine
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.parse">
            function <span class="apidocSignatureSpan">acorn.</span>parse
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.parseExpressionAt">
            function <span class="apidocSignatureSpan">acorn.</span>parseExpressionAt
            <span class="apidocSignatureSpan">(input, pos, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.tokenizer">
            function <span class="apidocSignatureSpan">acorn.</span>tokenizer
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>Parser.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>Position.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>defaultOptions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>keywordTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>lineBreak</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>lineBreakG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>nonASCIIwhitespace</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>tokContexts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">acorn.</span>tokTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">acorn.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Parser">module acorn.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.Parser">
            function <span class="apidocSignatureSpan">acorn.</span>Parser
            <span class="apidocSignatureSpan">(options, input, startPos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Parser.prototype">module acorn.Parser.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.afterTrailingComma">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>afterTrailingComma
            <span class="apidocSignatureSpan">(tokType, notNext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.braceIsBlock">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>braceIsBlock
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.buildBinary">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>buildBinary
            <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.canDeclareLexicalName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareLexicalName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.canDeclareVarName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareVarName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.canInsertSemicolon">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canInsertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExport
            <span class="apidocSignatureSpan">(exports, name, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkExpressionErrors">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExpressionErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkLVal">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkLVal
            <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkParams">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkParams
            <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkPatternErrors">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternErrors
            <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkPatternExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternExport
            <span class="apidocSignatureSpan">(exports, pat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkPropClash">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPropClash
            <span class="apidocSignatureSpan">(prop, propHash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkVariableExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkVariableExport
            <span class="apidocSignatureSpan">(exports, decls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.checkYieldAwaitInDefaultParams">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkYieldAwaitInDefaultParams
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.curContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.curPosition">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curPosition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.declareLexicalName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareLexicalName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.declareVarName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareVarName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.eat">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eat
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.eatContextual">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eatContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.enterFunctionScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterFunctionScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.enterLexicalScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterLexicalScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.exitFunctionScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitFunctionScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.exitLexicalScope">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitLexicalScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.expect">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expect
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.expectContextual">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expectContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.extend">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>extend
            <span class="apidocSignatureSpan">(name, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishNode">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNode
            <span class="apidocSignatureSpan">(node, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishNodeAt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNodeAt
            <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishOp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishOp
            <span class="apidocSignatureSpan">(type, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.finishToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishToken
            <span class="apidocSignatureSpan">(type, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.fullCharCodeAtPos">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>fullCharCodeAtPos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.getToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.getTokenFromCode">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getTokenFromCode
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.inGeneratorContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>inGeneratorContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.initFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initFunction
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.initialContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initialContext
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.insertSemicolon">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>insertSemicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isAsyncFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isAsyncFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isContextual">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isContextual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isKeyword">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isKeyword
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isLet">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isLet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isReservedWord">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isReservedWord
            <span class="apidocSignatureSpan">(word)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isSimpleAssignTarget">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleAssignTarget
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.isSimpleParamList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleParamList
            <span class="apidocSignatureSpan">(params)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.loadPlugins">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>loadPlugins
            <span class="apidocSignatureSpan">(pluginConfigs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.next">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.nextToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>nextToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseArrowExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseArrowExpression
            <span class="apidocSignatureSpan">(node, params, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseAwait">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseAwait
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBindingAtom">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingAtom
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBindingList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingList
            <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma, allowNonIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBindingListItem">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingListItem
            <span class="apidocSignatureSpan">(param)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBlock">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBlock
            <span class="apidocSignatureSpan">(createNewLexicalScope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseBreakContinueStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBreakContinueStatement
            <span class="apidocSignatureSpan">(node, keyword)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClass">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClass
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClassId">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassId
            <span class="apidocSignatureSpan">(node, isStatement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClassMethod">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassMethod
            <span class="apidocSignatureSpan">(classBody, method, isGenerator, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseClassSuper">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassSuper
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseDebuggerStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDebuggerStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseDoStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDoStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseEmptyStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseEmptyStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExport
            <span class="apidocSignatureSpan">(node, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExportSpecifiers">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExportSpecifiers
            <span class="apidocSignatureSpan">(exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprAtom">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprAtom
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprList
            <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprOp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOp
            <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprOps">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOps
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExprSubscripts">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprSubscripts
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpression
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseExpressionStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpressionStatement
            <span class="apidocSignatureSpan">(node, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFor">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFor
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseForIn">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForIn
            <span class="apidocSignatureSpan">(node, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseForStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunction">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunction
            <span class="apidocSignatureSpan">(node, isStatement, allowExpressionBody, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunctionBody">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionBody
            <span class="apidocSignatureSpan">(node, isArrowFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunctionParams">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionParams
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseFunctionStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionStatement
            <span class="apidocSignatureSpan">(node, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseIdent">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIdent
            <span class="apidocSignatureSpan">(liberal)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseIfStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIfStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseImport">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImport
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseImportSpecifiers">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImportSpecifiers
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseLabeledStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLabeledStatement
            <span class="apidocSignatureSpan">(node, maybeName, expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseLiteral">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLiteral
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeAssign">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeAssign
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeConditional">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeConditional
            <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeDefault">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeDefault
            <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMaybeUnary">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeUnary
            <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseMethod">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMethod
            <span class="apidocSignatureSpan">(isGenerator, isAsync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseNew">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseNew
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseObj">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseObj
            <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenAndDistinguishExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenAndDistinguishExpression
            <span class="apidocSignatureSpan">(canBeArrow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenArrowList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenArrowList
            <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenExpression">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseParenItem">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenItem
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parsePropertyName">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyName
            <span class="apidocSignatureSpan">(prop)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parsePropertyValue">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyValue
            <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseRest">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseRest
            <span class="apidocSignatureSpan">(allowNonIdent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseReturnStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseReturnStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseSpread">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSpread
            <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseStatement
            <span class="apidocSignatureSpan">(declaration, topLevel, exports)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseSubscripts">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSubscripts
            <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseSwitchStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSwitchStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTemplate">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTemplateElement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplateElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseThrowStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseThrowStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTopLevel">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTopLevel
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseTryStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTryStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseVar">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVar
            <span class="apidocSignatureSpan">(node, isFor, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseVarId">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarId
            <span class="apidocSignatureSpan">(decl, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseVarStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarStatement
            <span class="apidocSignatureSpan">(node, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseWhileStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWhileStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseWithStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWithStatement
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.parseYield">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseYield
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.raise">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raise
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.raiseRecoverable">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raiseRecoverable
            <span class="apidocSignatureSpan">(pos, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readCodePoint">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readCodePoint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readEscapedChar">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readEscapedChar
            <span class="apidocSignatureSpan">(inTemplate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readHexChar">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readHexChar
            <span class="apidocSignatureSpan">(len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readInt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readInt
            <span class="apidocSignatureSpan">(radix, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readNumber">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readNumber
            <span class="apidocSignatureSpan">(startsWithDot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readRadixNumber">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRadixNumber
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readRegexp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRegexp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readString">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readString
            <span class="apidocSignatureSpan">(quote)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readTmplToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readTmplToken
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_caret">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_caret
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_dot">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_dot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_eq_excl">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_eq_excl
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_lt_gt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_lt_gt
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_mult_modulo_exp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_mult_modulo_exp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_pipe_amp">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_pipe_amp
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_plus_min">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_plus_min
            <span class="apidocSignatureSpan">(code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readToken_slash">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_slash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readWord">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.readWord1">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.semicolon">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>semicolon
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.shouldParseExportStatement">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>shouldParseExportStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.skipBlockComment">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipBlockComment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.skipLineComment">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipLineComment
            <span class="apidocSignatureSpan">(startSkip)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.skipSpace">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipSpace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.startNode">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.startNodeAt">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNodeAt
            <span class="apidocSignatureSpan">(pos, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.strictDirective">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>strictDirective
            <span class="apidocSignatureSpan">(start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.toAssignable">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignable
            <span class="apidocSignatureSpan">(node, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.toAssignableList">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignableList
            <span class="apidocSignatureSpan">(exprList, isBinding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.unexpected">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>unexpected
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Parser.prototype.updateContext">
            function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>updateContext
            <span class="apidocSignatureSpan">(prevType)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Position">module acorn.Position</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Position.Position">
            function <span class="apidocSignatureSpan">acorn.</span>Position
            <span class="apidocSignatureSpan">(line, col)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.acorn.Position.prototype">module acorn.Position.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.acorn.Position.prototype.offset">
            function <span class="apidocSignatureSpan">acorn.Position.prototype.</span>offset
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn" id="apidoc.module.acorn">module acorn</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Node" id="apidoc.element.acorn.Node">
        function <span class="apidocSignatureSpan">acorn.</span>Node
        <span class="apidocSignatureSpan">(parser, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(parser, pos, loc) {
  this.type = ""
  this.start = pos
  this.end = 0
  if (parser.options.locations)
    this.loc = new SourceLocation(parser, loc)
  if (parser.options.directSourceFile)
    this.sourceFile = parser.options.directSourceFile
  if (parser.options.ranges)
    this.range = [pos, 0]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser" id="apidoc.element.acorn.Parser">
        function <span class="apidocSignatureSpan">acorn.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options)
  this.sourceFile = options.sourceFile
  this.keywords = keywordRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : 5])
  var reserved = ""
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      if (reserved = reservedWords[v]) break
    if (options.sourceType == "module") reserved += " await"
  }
  this.reservedWords = keywordRegexp(reserved)
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict
  this.reservedWordsStrict = keywordRegexp(reservedStrict)
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind)
  this.input = String(input)

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false

  // Load plugins
  this.loadPlugins(options.plugins)

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
  } else {
    this.pos = this.lineStart = 0
    this.curLine = 1
  }

  // Properties of the current token:
  // Its type
  this.type = tt.eof
  // For tokens that include more information than their type, the value
  this.value = null
  // Its start and end offset
  this.start = this.end = this.pos
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition()

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null
  this.lastTokStart = this.lastTokEnd = this.pos

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext()
  this.exprAllowed = true

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module"
  this.strict = this.inModule || this.strictDirective(this.pos)

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0
  // Labels in scope.
  this.labels = []

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === "#!")
    this.skipLineComment(2)

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = []
  this.enterFunctionScope()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Position" id="apidoc.element.acorn.Position">
        function <span class="apidocSignatureSpan">acorn.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line
  this.column = col
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.SourceLocation" id="apidoc.element.acorn.SourceLocation">
        function <span class="apidocSignatureSpan">acorn.</span>SourceLocation
        <span class="apidocSignatureSpan">(p, start, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SourceLocation(p, start, end) {
  this.start = start
  this.end = end
  if (p.sourceFile !== null) this.source = p.sourceFile
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.TokContext" id="apidoc.element.acorn.TokContext">
        function <span class="apidocSignatureSpan">acorn.</span>TokContext
        <span class="apidocSignatureSpan">(token, isExpr, preserveSpace, override, generator)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token
  this.isExpr = !!isExpr
  this.preserveSpace = !!preserveSpace
  this.override = override
  this.generator = !!generator
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Token" id="apidoc.element.acorn.Token">
        function <span class="apidocSignatureSpan">acorn.</span>Token
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Token(p) {
  this.type = p.type
  this.value = p.value
  this.start = p.start
  this.end = p.end
  if (p.options.locations)
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
  if (p.options.ranges)
    this.range = [p.start, p.end]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.TokenType" id="apidoc.element.acorn.TokenType">
        function <span class="apidocSignatureSpan">acorn.</span>TokenType
        <span class="apidocSignatureSpan">(label, conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label
  this.keyword = conf.keyword
  this.beforeExpr = !!conf.beforeExpr
  this.startsExpr = !!conf.startsExpr
  this.isLoop = !!conf.isLoop
  this.isAssign = !!conf.isAssign
  this.prefix = !!conf.prefix
  this.postfix = !!conf.postfix
  this.binop = conf.binop || null
  this.updateContext = null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.addLooseExports" id="apidoc.element.acorn.addLooseExports">
        function <span class="apidocSignatureSpan">acorn.</span>addLooseExports
        <span class="apidocSignatureSpan">(parse, Parser, plugins)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addLooseExports(parse, Parser, plugins) {
  exports.parse_dammit = parse // eslint-disable-line camelcase
  exports.LooseParser = Parser
  exports.pluginsLoose = plugins
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.getLineInfo" id="apidoc.element.acorn.getLineInfo">
        function <span class="apidocSignatureSpan">acorn.</span>getLineInfo
        <span class="apidocSignatureSpan">(input, offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur
    var match = lineBreakG.exec(input)
    if (match &amp;&amp; match.index &lt; offset) {
      ++line
      cur = match.index + match[0].length
    } else {
      return new Position(line, offset - cur)
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.isIdentifierChar" id="apidoc.element.acorn.isIdentifierChar">
        function <span class="apidocSignatureSpan">acorn.</span>isIdentifierChar
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierChar(code, astral) {
  if (code &lt; 48) return code === 36
  if (code &lt; 58) return true
  if (code &lt; 65) return false
  if (code &lt; 91) return true
  if (code &lt; 97) return code === 95
  if (code &lt; 123) return true
  if (code &lt;= 0xffff) return code &gt;= 0xaa &amp;&amp; nonASCIIidentifier.test(String.fromCharCode(code))
  if (astral === false) return false
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.isIdentifierStart" id="apidoc.element.acorn.isIdentifierStart">
        function <span class="apidocSignatureSpan">acorn.</span>isIdentifierStart
        <span class="apidocSignatureSpan">(code, astral)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isIdentifierStart(code, astral) {
  if (code &lt; 65) return code === 36
  if (code &lt; 91) return true
  if (code &lt; 97) return code === 95
  if (code &lt; 123) return true
  if (code &lt;= 0xffff) return code &gt;= 0xaa &amp;&amp; nonASCIIidentifierStart.test(String.fromCharCode(code))
  if (astral === false) return false
  return isInAstralSet(code, astralIdentifierStartCodes)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.isNewLine" id="apidoc.element.acorn.isNewLine">
        function <span class="apidocSignatureSpan">acorn.</span>isNewLine
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.parse" id="apidoc.element.acorn.parse">
        function <span class="apidocSignatureSpan">acorn.</span>parse
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(input, options) {
  return new Parser(options, input).parse()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Escodegen supports generating comments from AST, attached in
Esprima-specific format. In order to simulate same format in
Acorn, consider following example:

```javascript
var comments = [], tokens = [];

var ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>('var x = 42; // answer', {
	// collect ranges for each node
	ranges: true,
	// collect comments in Esprima's format
	onComment: comments,
	// collect token ranges
	onToken: tokens
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.parseExpressionAt" id="apidoc.element.acorn.parseExpressionAt">
        function <span class="apidocSignatureSpan">acorn.</span>parseExpressionAt
        <span class="apidocSignatureSpan">(input, pos, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseExpressionAt(input, pos, options) {
  var p = new Parser(options, input, pos)
  p.nextToken()
  return p.parseExpression()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.tokenizer" id="apidoc.element.acorn.tokenizer">
        function <span class="apidocSignatureSpan">acorn.</span>tokenizer
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tokenizer(input, options) {
  return new Parser(options, input)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
should stop calling the method, since it will keep returning that same
token forever.

In ES6 environment, returned result can be used as any other
protocol-compliant iterable:

```javascript
for (let token of acorn.<span class="apidocCodeKeywordSpan">tokenizer</span>(str)) {
  // iterate over the tokens
}

// transform code to array of tokens:
var tokens = [...acorn.tokenizer(str)];
```
...</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Parser" id="apidoc.module.acorn.Parser">module acorn.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Parser.Parser" id="apidoc.element.acorn.Parser.Parser">
        function <span class="apidocSignatureSpan">acorn.</span>Parser
        <span class="apidocSignatureSpan">(options, input, startPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Parser(options, input, startPos) {
  this.options = options = getOptions(options)
  this.sourceFile = options.sourceFile
  this.keywords = keywordRegexp(keywords[options.ecmaVersion &gt;= 6 ? 6 : 5])
  var reserved = ""
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      if (reserved = reservedWords[v]) break
    if (options.sourceType == "module") reserved += " await"
  }
  this.reservedWords = keywordRegexp(reserved)
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict
  this.reservedWordsStrict = keywordRegexp(reservedStrict)
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind)
  this.input = String(input)

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false

  // Load plugins
  this.loadPlugins(options.plugins)

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
  } else {
    this.pos = this.lineStart = 0
    this.curLine = 1
  }

  // Properties of the current token:
  // Its type
  this.type = tt.eof
  // For tokens that include more information than their type, the value
  this.value = null
  // Its start and end offset
  this.start = this.end = this.pos
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition()

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null
  this.lastTokStart = this.lastTokEnd = this.pos

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext()
  this.exprAllowed = true

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module"
  this.strict = this.inModule || this.strictDirective(this.pos)

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0
  // Labels in scope.
  this.labels = []

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 &amp;&amp; options.allowHashBang &amp;&amp; this.input.slice(0, 2) === "#!")
    this.skipLineComment(2)

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = []
  this.enterFunctionScope()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Parser.prototype" id="apidoc.module.acorn.Parser.prototype">module acorn.Parser.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.afterTrailingComma" id="apidoc.element.acorn.Parser.prototype.afterTrailingComma">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>afterTrailingComma
        <span class="apidocSignatureSpan">(tokType, notNext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">afterTrailingComma = function (tokType, notNext) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma)
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
    if (!notNext)
      this.next()
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.braceIsBlock" id="apidoc.element.acorn.Parser.prototype.braceIsBlock">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>braceIsBlock
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">braceIsBlock = function (prevType) {
  if (prevType === tt.colon) {
    var parent = this.curContext()
    if (parent === types.b_stat || parent === types.b_expr)
      return !parent.isExpr
  }
  if (prevType === tt._return)
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR || prevType == tt.arrow)
    return true
  if (prevType == tt.braceL)
    return this.curContext() === types.b_stat
  return !this.exprAllowed
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.buildBinary" id="apidoc.element.acorn.Parser.prototype.buildBinary">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>buildBinary
        <span class="apidocSignatureSpan">(startPos, startLoc, left, right, op, logical)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buildBinary = function (startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc)
  node.left = left
  node.operator = op
  node.right = right
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.canDeclareLexicalName" id="apidoc.element.acorn.Parser.prototype.canDeclareLexicalName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareLexicalName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1]

  return !has(currentScope.lexical, name) &amp;&amp; !has(currentScope.var, name) &amp;&amp; !has(currentScope.childVar, name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.canDeclareVarName" id="apidoc.element.acorn.Parser.prototype.canDeclareVarName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canDeclareVarName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1]

  return !has(currentScope.lexical, name) &amp;&amp; !has(currentScope.parentLexical, name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.canInsertSemicolon" id="apidoc.element.acorn.Parser.prototype.canInsertSemicolon">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>canInsertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canInsertSemicolon = function () {
  return this.type === tt.eof ||
    this.type === tt.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkExport" id="apidoc.element.acorn.Parser.prototype.checkExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExport
        <span class="apidocSignatureSpan">(exports, name, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkExport = function (exports, name, pos) {
  if (!exports) return
  if (has(exports, name))
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'")
  exports[name] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkExpressionErrors" id="apidoc.element.acorn.Parser.prototype.checkExpressionErrors">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkExpressionErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, andThrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkExpressionErrors = function (refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1
  if (!andThrow) return pos &gt;= 0
  if (pos &gt; -1) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkLVal" id="apidoc.element.acorn.Parser.prototype.checkLVal">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkLVal
        <span class="apidocSignatureSpan">(expr, bindingType, checkClashes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkLVal = function (expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case "Identifier":
    if (this.strict &amp;&amp; this.reservedWordsStrictBind.test(expr.name))
      this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode")
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        this.raiseRecoverable(expr.start, "Argument name clash")
      checkClashes[expr.name] = true
    }
    if (bindingType &amp;&amp; bindingType !== "none") {
      if (
        bindingType === "var" &amp;&amp; !this.canDeclareVarName(expr.name) ||
        bindingType !== "var" &amp;&amp; !this.canDeclareLexicalName(expr.name)
      ) {
        this.raiseRecoverable(expr.start, ("Identifier '" + (expr.name) + "' has already been declared"))
      }
      if (bindingType === "var") {
        this.declareVarName(expr.name)
      } else {
        this.declareLexicalName(expr.name)
      }
    }
    break

  case "MemberExpression":
    if (bindingType) this.raiseRecoverable(expr.start, (bindingType ? "Binding" : "Assigning to") + " member expression")
    break

  case "ObjectPattern":
    for (var i = 0; i &lt; expr.properties.length; i++)
      this$1.checkLVal(expr.properties[i].value, bindingType, checkClashes)
    break

  case "ArrayPattern":
    for (var i$1 = 0; i$1 &lt; expr.elements.length; i$1++) {
      var elem = expr.elements[i$1]
      if (elem) this$1.checkLVal(elem, bindingType, checkClashes)
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes)
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes)
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes)
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue")
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkParams" id="apidoc.element.acorn.Parser.prototype.checkParams">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkParams
        <span class="apidocSignatureSpan">(node, allowDuplicates)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkParams = function (node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {}
  for (var i = 0; i &lt; node.params.length; i++) this$1.checkLVal(node.params[i], "var", allowDuplicates ? null : nameHash)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkPatternErrors" id="apidoc.element.acorn.Parser.prototype.checkPatternErrors">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternErrors
        <span class="apidocSignatureSpan">(refDestructuringErrors, isAssign)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPatternErrors = function (refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) return
  if (refDestructuringErrors.trailingComma &gt; -1)
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element")
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind
  if (parens &gt; -1) this.raiseRecoverable(parens, "Parenthesized pattern")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkPatternExport" id="apidoc.element.acorn.Parser.prototype.checkPatternExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPatternExport
        <span class="apidocSignatureSpan">(exports, pat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPatternExport = function (exports, pat) {
  var this$1 = this;

  var type = pat.type
  if (type == "Identifier")
    this.checkExport(exports, pat.name, pat.start)
  else if (type == "ObjectPattern")
    for (var i = 0; i &lt; pat.properties.length; ++i)
      this$1.checkPatternExport(exports, pat.properties[i].value)
  else if (type == "ArrayPattern")
    for (var i$1 = 0; i$1 &lt; pat.elements.length; ++i$1) {
      var elt = pat.elements[i$1]
      if (elt) this$1.checkPatternExport(exports, elt)
    }
  else if (type == "AssignmentPattern")
    this.checkPatternExport(exports, pat.left)
  else if (type == "ParenthesizedExpression")
    this.checkPatternExport(exports, pat.expression)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkPropClash" id="apidoc.element.acorn.Parser.prototype.checkPropClash">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkPropClash
        <span class="apidocSignatureSpan">(prop, propHash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkPropClash = function (prop, propHash) {
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; (prop.computed || prop.method || prop.shorthand))
    return
  var key = prop.key;
  var name
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion &gt;= 6) {
    if (name === "__proto__" &amp;&amp; kind === "init") {
      if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property")
      propHash.proto = true
    }
    return
  }
  name = "$" + name
  var other = propHash[name]
  if (other) {
    var redefinition
    if (kind === "init") {
      redefinition = this.strict &amp;&amp; other.init || other.get || other.set
    } else {
      redefinition = other.init || other[kind]
    }
    if (redefinition)
      this.raiseRecoverable(key.start, "Redefinition of property")
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    }
  }
  other[kind] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkVariableExport" id="apidoc.element.acorn.Parser.prototype.checkVariableExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkVariableExport
        <span class="apidocSignatureSpan">(exports, decls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkVariableExport = function (exports, decls) {
  var this$1 = this;

  if (!exports) return
  for (var i = 0; i &lt; decls.length; i++)
    this$1.checkPatternExport(exports, decls[i].id)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.checkYieldAwaitInDefaultParams" id="apidoc.element.acorn.Parser.prototype.checkYieldAwaitInDefaultParams">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>checkYieldAwaitInDefaultParams
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkYieldAwaitInDefaultParams = function () {
  if (this.yieldPos &amp;&amp; (!this.awaitPos || this.yieldPos &lt; this.awaitPos))
    this.raise(this.yieldPos, "Yield expression cannot be a default value")
  if (this.awaitPos)
    this.raise(this.awaitPos, "Await expression cannot be a default value")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.curContext" id="apidoc.element.acorn.Parser.prototype.curContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">curContext = function () {
  return this.context[this.context.length - 1]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.curPosition" id="apidoc.element.acorn.Parser.prototype.curPosition">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>curPosition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">curPosition = function () {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.declareLexicalName" id="apidoc.element.acorn.Parser.prototype.declareLexicalName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareLexicalName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.declareVarName" id="apidoc.element.acorn.Parser.prototype.declareVarName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>declareVarName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.eat" id="apidoc.element.acorn.Parser.prototype.eat">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eat
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eat = function (type) {
  if (this.type === type) {
    this.next()
    return true
  } else {
    return false
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.eatContextual" id="apidoc.element.acorn.Parser.prototype.eatContextual">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>eatContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eatContextual = function (name) {
  return this.value === name &amp;&amp; this.eat(tt.name)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.enterFunctionScope" id="apidoc.element.acorn.Parser.prototype.enterFunctionScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterFunctionScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enterFunctionScope = function () {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function
 scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current
 function scope)
  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.enterLexicalScope" id="apidoc.element.acorn.Parser.prototype.enterLexicalScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>enterLexicalScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1]
  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}}

  this.scopeStack.push(childScope)
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.exitFunctionScope" id="apidoc.element.acorn.Parser.prototype.exitFunctionScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitFunctionScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitFunctionScope = function () {
  this.scopeStack.pop()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.exitLexicalScope" id="apidoc.element.acorn.Parser.prototype.exitLexicalScope">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>exitLexicalScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exitLexicalScope = function () {
  var childScope = this.scopeStack.pop()
  var parentScope = this.scopeStack[this.scopeStack.length - 1]

  assign(parentScope.childVar, childScope.var, childScope.childVar)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.expect" id="apidoc.element.acorn.Parser.prototype.expect">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expect
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expect = function (type) {
  this.eat(type) || this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.expectContextual" id="apidoc.element.acorn.Parser.prototype.expectContextual">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>expectContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expectContextual = function (name) {
  if (!this.eatContextual(name)) this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.extend" id="apidoc.element.acorn.Parser.prototype.extend">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>extend
        <span class="apidocSignatureSpan">(name, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(name, f) {
  this[name] = f(this[name])
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options). After the parser object has been created, the initialization
functions for the chosen plugins are called with `(parser,
configValue)` arguments. They are expected to use the `parser.extend`
method to extend parser methods. For example, the `readToken` method
could be extended like this:

```javascript
parser.<span class="apidocCodeKeywordSpan">extend</span>("readToken", function(nextMethod) {
  return function(code) {
    console.log("Reading a token!")
    return nextMethod.call(this, code)
  }
})
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishNode" id="apidoc.element.acorn.Parser.prototype.finishNode">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNode
        <span class="apidocSignatureSpan">(node, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishNodeAt" id="apidoc.element.acorn.Parser.prototype.finishNodeAt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishNodeAt
        <span class="apidocSignatureSpan">(node, type, pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishOp" id="apidoc.element.acorn.Parser.prototype.finishOp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishOp
        <span class="apidocSignatureSpan">(type, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishOp = function (type, size) {
  var str = this.input.slice(this.pos, this.pos + size)
  this.pos += size
  return this.finishToken(type, str)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.finishToken" id="apidoc.element.acorn.Parser.prototype.finishToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>finishToken
        <span class="apidocSignatureSpan">(type, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finishToken = function (type, val) {
  this.end = this.pos
  if (this.options.locations) this.endLoc = this.curPosition()
  var prevType = this.type
  this.type = type
  this.value = val

  this.updateContext(prevType)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.fullCharCodeAtPos" id="apidoc.element.acorn.Parser.prototype.fullCharCodeAtPos">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>fullCharCodeAtPos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fullCharCodeAtPos = function () {
  var code = this.input.charCodeAt(this.pos)
  if (code &lt;= 0xd7ff || code &gt;= 0xe000) return code
  var next = this.input.charCodeAt(this.pos + 1)
  return (code &lt;&lt; 10) + next - 0x35fdc00
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.getToken" id="apidoc.element.acorn.Parser.prototype.getToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getToken = function () {
  this.next()
  return new Token(this)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
- **locations**: When `true`, each node has a `loc` object attached
  with `start` and `end` subobjects, each of which contains the
  one-based line and zero-based column numbers in `{line, column}`
  form. Default is `false`.

- **onToken**: If a function is passed for this option, each found
  token will be passed in same format as tokens returned from
  `tokenizer().<span class="apidocCodeKeywordSpan">getToken</span>()`.

  If array is passed, each found token is pushed to it.

  Note that you are not allowed to call the parser from the
  callbackâ€”that will corrupt its internal state.

- **onComment**: If a function is passed for this option, whenever a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.getTokenFromCode" id="apidoc.element.acorn.Parser.prototype.getTokenFromCode">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>getTokenFromCode
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTokenFromCode = function (code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

    // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(tt.parenL)
  case 41: ++this.pos; return this.finishToken(tt.parenR)
  case 59: ++this.pos; return this.finishToken(tt.semi)
  case 44: ++this.pos; return this.finishToken(tt.comma)
  case 91: ++this.pos; return this.finishToken(tt.bracketL)
  case 93: ++this.pos; return this.finishToken(tt.bracketR)
  case 123: ++this.pos; return this.finishToken(tt.braceL)
  case 125: ++this.pos; return this.finishToken(tt.braceR)
  case 58: ++this.pos; return this.finishToken(tt.colon)
  case 63: ++this.pos; return this.finishToken(tt.question)

  case 96: // '`'
    if (this.options.ecmaVersion &lt; 6) break
    ++this.pos
    return this.finishToken(tt.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1)
    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number
    if (this.options.ecmaVersion &gt;= 6) {
      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number
      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

    // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&amp;'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '&lt;&gt;'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(tt.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.inGeneratorContext" id="apidoc.element.acorn.Parser.prototype.inGeneratorContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>inGeneratorContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inGeneratorContext = function () {
  var this$1 = this;

  for (var i = this.context.length - 1; i &gt;= 0; i--)
    if (this$1.context[i].generator) return true
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.initFunction" id="apidoc.element.acorn.Parser.prototype.initFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initFunction
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initFunction = function (node) {
  node.id = null
  if (this.options.ecmaVersion &gt;= 6) {
    node.generator = false
    node.expression = false
  }
  if (this.options.ecmaVersion &gt;= 8)
    node.async = false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.initialContext" id="apidoc.element.acorn.Parser.prototype.initialContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>initialContext
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialContext = function () {
  return [types.b_stat]
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.insertSemicolon" id="apidoc.element.acorn.Parser.prototype.insertSemicolon">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>insertSemicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertSemicolon = function () {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
    return true
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isAsyncFunction" id="apidoc.element.acorn.Parser.prototype.isAsyncFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isAsyncFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAsyncFunction = function () {
  if (this.type !== tt.name || this.options.ecmaVersion &lt; 8 || this.value != "async")
    return false

  skipWhiteSpace.lastIndex = this.pos
  var skip = skipWhiteSpace.exec(this.input)
  var next = this.pos + skip[0].length
  return !lineBreak.test(this.input.slice(this.pos, next)) &amp;&amp;
    this.input.slice(next, next + 8) === "function" &amp;&amp;
    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isContextual" id="apidoc.element.acorn.Parser.prototype.isContextual">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isContextual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isContextual = function (name) {
  return this.type === tt.name &amp;&amp; this.value === name
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isFunction" id="apidoc.element.acorn.Parser.prototype.isFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFunction = function () {
  return this.type === tt._function || this.isAsyncFunction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isKeyword" id="apidoc.element.acorn.Parser.prototype.isKeyword">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isKeyword
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isKeyword(word) { return this.keywords.test(word) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isLet" id="apidoc.element.acorn.Parser.prototype.isLet">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isLet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLet = function () {
  if (this.type !== tt.name || this.options.ecmaVersion &lt; 6 || this.value != "let") return false
  skipWhiteSpace.lastIndex = this.pos
  var skip = skipWhiteSpace.exec(this.input)
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)
  if (nextCh === 91 || nextCh == 123) return true // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) ++pos
    var ident = this.input.slice(next, pos)
    if (!this.isKeyword(ident)) return true
  }
  return false
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isReservedWord" id="apidoc.element.acorn.Parser.prototype.isReservedWord">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isReservedWord
        <span class="apidocSignatureSpan">(word)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isReservedWord(word) { return this.reservedWords.test(word) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isSimpleAssignTarget" id="apidoc.element.acorn.Parser.prototype.isSimpleAssignTarget">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleAssignTarget
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleAssignTarget = function (expr) {
  if (expr.type === "ParenthesizedExpression")
    return this.isSimpleAssignTarget(expr.expression)
  return expr.type === "Identifier" || expr.type === "MemberExpression"
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.isSimpleParamList" id="apidoc.element.acorn.Parser.prototype.isSimpleParamList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>isSimpleParamList
        <span class="apidocSignatureSpan">(params)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSimpleParamList = function (params) {
  for (var i = 0; i &lt; params.length; i++)
    if (params[i].type !== "Identifier") return false
  return true
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.loadPlugins" id="apidoc.element.acorn.Parser.prototype.loadPlugins">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>loadPlugins
        <span class="apidocSignatureSpan">(pluginConfigs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadPlugins(pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name]
    if (!plugin) throw new Error("Plugin '" + name + "' not found")
    plugin(this$1, pluginConfigs[name])
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.next" id="apidoc.element.acorn.Parser.prototype.next">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
  if (this.options.onToken)
    this.options.onToken(new Token(this))

  this.lastTokEnd = this.end
  this.lastTokStart = this.start
  this.lastTokEndLoc = this.endLoc
  this.lastTokStartLoc = this.startLoc
  this.nextToken()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.nextToken" id="apidoc.element.acorn.Parser.prototype.nextToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>nextToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextToken = function () {
  var curContext = this.curContext()
  if (!curContext || !curContext.preserveSpace) this.skipSpace()

  this.start = this.pos
  if (this.options.locations) this.startLoc = this.curPosition()
  if (this.pos &gt;= this.input.length) return this.finishToken(tt.eof)

  if (curContext.override) return curContext.override(this)
  else this.readToken(this.fullCharCodeAtPos())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parse" id="apidoc.element.acorn.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse() {
  var node = this.options.program || this.startNode()
  this.nextToken()
  return this.parseTopLevel(node)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Escodegen supports generating comments from AST, attached in
Esprima-specific format. In order to simulate same format in
Acorn, consider following example:

```javascript
var comments = [], tokens = [];

var ast = acorn.<span class="apidocCodeKeywordSpan">parse</span>('var x = 42; // answer', {
	// collect ranges for each node
	ranges: true,
	// collect comments in Esprima's format
	onComment: comments,
	// collect token ranges
	onToken: tokens
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseArrowExpression" id="apidoc.element.acorn.Parser.prototype.parseArrowExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseArrowExpression
        <span class="apidocSignatureSpan">(node, params, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseArrowExpression = function (node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction

  this.enterFunctionScope()
  this.initFunction(node)
  if (this.options.ecmaVersion &gt;= 8)
    node.async = !!isAsync

  this.inGenerator = false
  this.inAsync = node.async
  this.yieldPos = 0
  this.awaitPos = 0
  this.inFunction = true

  node.params = this.toAssignableList(params, true)
  this.parseFunctionBody(node, true)

  this.inGenerator = oldInGen
  this.inAsync = oldInAsync
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, "ArrowFunctionExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseAwait" id="apidoc.element.acorn.Parser.prototype.parseAwait">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseAwait
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseAwait = function () {
  if (!this.awaitPos) this.awaitPos = this.start

  var node = this.startNode()
  this.next()
  node.argument = this.parseMaybeUnary(null, true)
  return this.finishNode(node, "AwaitExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBindingAtom" id="apidoc.element.acorn.Parser.prototype.parseBindingAtom">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingAtom
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingAtom = function () {
  if (this.options.ecmaVersion &lt; 6) return this.parseIdent()
  switch (this.type) {
  case tt.name:
    return this.parseIdent()

  case tt.bracketL:
    var node = this.startNode()
    this.next()
    node.elements = this.parseBindingList(tt.bracketR, true, true)
    return this.finishNode(node, "ArrayPattern")

  case tt.braceL:
    return this.parseObj(true)

  default:
    this.unexpected()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBindingList" id="apidoc.element.acorn.Parser.prototype.parseBindingList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingList
        <span class="apidocSignatureSpan">(close, allowEmpty, allowTrailingComma, allowNonIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
  var this$1 = this;

  var elts = [], first = true
  while (!this.eat(close)) {
    if (first) first = false
    else this$1.expect(tt.comma)
    if (allowEmpty &amp;&amp; this$1.type === tt.comma) {
      elts.push(null)
    } else if (allowTrailingComma &amp;&amp; this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === tt.ellipsis) {
      var rest = this$1.parseRest(allowNonIdent)
      this$1.parseBindingListItem(rest)
      elts.push(rest)
      if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element")
      this$1.expect(close)
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
      this$1.parseBindingListItem(elem)
      elts.push(elem)
    }
  }
  return elts
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBindingListItem" id="apidoc.element.acorn.Parser.prototype.parseBindingListItem">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBindingListItem
        <span class="apidocSignatureSpan">(param)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingListItem = function (param) {
  return param
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBlock" id="apidoc.element.acorn.Parser.prototype.parseBlock">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBlock
        <span class="apidocSignatureSpan">(createNewLexicalScope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBlock = function (createNewLexicalScope) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;

  var node = this.startNode()
  node.body = []
  this.expect(tt.braceL)
  if (createNewLexicalScope) {
    this.enterLexicalScope()
  }
  while (!this.eat(tt.braceR)) {
    var stmt = this$1.parseStatement(true)
    node.body.push(stmt)
  }
  if (createNewLexicalScope) {
    this.exitLexicalScope()
  }
  return this.finishNode(node, "BlockStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseBreakContinueStatement" id="apidoc.element.acorn.Parser.prototype.parseBreakContinueStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseBreakContinueStatement
        <span class="apidocSignatureSpan">(node, keyword)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBreakContinueStatement = function (node, keyword) {
  var this$1 = this;

  var isBreak = keyword == "break"
  this.next()
  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
  else if (this.type !== tt.name) this.unexpected()
  else {
    node.label = this.parseIdent()
    this.semicolon()
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0
  for (; i &lt; this.labels.length; ++i) {
    var lab = this$1.labels[i]
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null &amp;&amp; (isBreak || lab.kind === "loop")) break
      if (node.label &amp;&amp; isBreak) break
    }
  }
  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword)
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClass" id="apidoc.element.acorn.Parser.prototype.parseClass">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClass
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClass = function (node, isStatement) {
  var this$1 = this;

  this.next()

  this.parseClassId(node, isStatement)
  this.parseClassSuper(node)
  var classBody = this.startNode()
  var hadConstructor = false
  classBody.body = []
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (this$1.eat(tt.semi)) continue
    var method = this$1.startNode()
    var isGenerator = this$1.eat(tt.star)
    var isAsync = false
    var isMaybeStatic = this$1.type === tt.name &amp;&amp; this$1.value === "static"
    this$1.parsePropertyName(method)
    method.static = isMaybeStatic &amp;&amp; this$1.type !== tt.parenL
    if (method.static) {
      if (isGenerator) this$1.unexpected()
      isGenerator = this$1.eat(tt.star)
      this$1.parsePropertyName(method)
    }
    if (this$1.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; !method.computed &amp;&amp;
        method.key.type === "Identifier" &amp;&amp; method.key.name === "async" &amp;&amp; this$1.type !== tt.parenL &amp;&amp;
        !this$1.canInsertSemicolon()) {
      isAsync = true
      this$1.parsePropertyName(method)
    }
    method.kind = "method"
    var isGetSet = false
    if (!method.computed) {
      var key = method.key;
      if (!isGenerator &amp;&amp; !isAsync &amp;&amp; key.type === "Identifier" &amp;&amp; this$1.type !== tt.parenL &amp;&amp; (key.name === "get" || key.name === "
set")) {
        isGetSet = true
        method.kind = key.name
        key = this$1.parsePropertyName(method)
      }
      if (!method.static &amp;&amp; (key.type === "Identifier" &amp;&amp; key.name === "constructor" ||
          key.type === "Literal" &amp;&amp; key.value === "constructor")) {
        if (hadConstructor) this$1.raise(key.start, "Duplicate constructor in the same class")
        if (isGetSet) this$1.raise(key.start, "Constructor can't have get/set modifier")
        if (isGenerator) this$1.raise(key.start, "Constructor can't be a generator")
        if (isAsync) this$1.raise(key.start, "Constructor can't be an async method")
        method.kind = "constructor"
        hadConstructor = true
      }
    }
    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1
      if (method.value.params.length !== paramCount) {
        var start = method.value.start
        if (method.kind === "get")
          this$1.raiseRecoverable(start, "getter should have no params")
        else
          this$1.raiseRecoverable(start, "setter should have exactly one param")
      } else {
        if (method.kind === "set" &amp;&amp; method.value.params[0].type === "RestElement")
          this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params")
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody")
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClassId" id="apidoc.element.acorn.Parser.prototype.parseClassId">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassId
        <span class="apidocSignatureSpan">(node, isStatement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClassId = function (node, isStatement) {
  node.id = this.type === tt.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClassMethod" id="apidoc.element.acorn.Parser.prototype.parseClassMethod">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassMethod
        <span class="apidocSignatureSpan">(classBody, method, isGenerator, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync)
  classBody.body.push(this.finishNode(method, "MethodDefinition"))
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseClassSuper" id="apidoc.element.acorn.Parser.prototype.parseClassSuper">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseClassSuper
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseClassSuper = function (node) {
  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseDebuggerStatement" id="apidoc.element.acorn.Parser.prototype.parseDebuggerStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDebuggerStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDebuggerStatement = function (node) {
  this.next()
  this.semicolon()
  return this.finishNode(node, "DebuggerStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseDoStatement" id="apidoc.element.acorn.Parser.prototype.parseDoStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseDoStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDoStatement = function (node) {
  this.next()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  this.expect(tt._while)
  node.test = this.parseParenExpression()
  if (this.options.ecmaVersion &gt;= 6)
    this.eat(tt.semi)
  else
    this.semicolon()
  return this.finishNode(node, "DoWhileStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseEmptyStatement" id="apidoc.element.acorn.Parser.prototype.parseEmptyStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseEmptyStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseEmptyStatement = function (node) {
  this.next()
  return this.finishNode(node, "EmptyStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExport" id="apidoc.element.acorn.Parser.prototype.parseExport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExport
        <span class="apidocSignatureSpan">(node, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExport = function (node, exports) {
  var this$1 = this;

  this.next()
  // export * from '...'
  if (this.eat(tt.star)) {
    this.expectContextual("from")
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
    this.semicolon()
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(tt._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart)
    var isAsync
    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode()
      this.next()
      if (isAsync) this.next()
      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync)
    } else if (this.type === tt._class) {
      var cNode = this.startNode()
      node.declaration = this.parseClass(cNode, "nullableID")
    } else {
      node.declaration = this.parseMaybeAssign()
      this.semicolon()
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true)
    if (node.declaration.type === "VariableDeclaration")
      this.checkVariableExport(exports, node.declaration.declarations)
    else
      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)
    node.specifiers = []
    node.source = null
  } else { // export { x, y as z } [from '...']
    node.declaration = null
    node.specifiers = this.parseExportSpecifiers(exports)
    if (this.eatContextual("from")) {
      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
    } else {
      // check for keywords used as local names
      for (var i = 0; i &lt; node.specifiers.length; i++) {
        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
          this$1.unexpected(node.specifiers[i].local.start)
        }
      }

      node.source = null
    }
    this.semicolon()
  }
  return this.finishNode(node, "ExportNamedDeclaration")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExportSpecifiers" id="apidoc.element.acorn.Parser.prototype.parseExportSpecifiers">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExportSpecifiers
        <span class="apidocSignatureSpan">(exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExportSpecifiers = function (exports) {
  var this$1 = this;

  var nodes = [], first = true
  // export { x, y as z } [from '...']
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false

    var node = this$1.startNode()
    node.local = this$1.parseIdent(true)
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local
    this$1.checkExport(exports, node.exported.name, node.exported.start)
    nodes.push(this$1.finishNode(node, "ExportSpecifier"))
  }
  return nodes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprAtom" id="apidoc.element.acorn.Parser.prototype.parseExprAtom">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprAtom
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprAtom = function (refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt == this.start
  switch (this.type) {
  case tt._super:
    if (!this.inFunction)
      this.raise(this.start, "'super' outside of function or class")

  case tt._this:
    var type = this.type === tt._this ? "ThisExpression" : "Super"
    node = this.startNode()
    this.next()
    return this.finishNode(node, type)

  case tt.name:
    var startPos = this.start, startLoc = this.startLoc
    var id = this.parseIdent(this.type !== tt.name)
    if (this.options.ecmaVersion &gt;= 8 &amp;&amp; id.name === "async" &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(tt._function))
      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)
    if (canBeArrow &amp;&amp; !this.canInsertSemicolon()) {
      if (this.eat(tt.arrow))
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)
      if (this.options.ecmaVersion &gt;= 8 &amp;&amp; id.name === "async" &amp;&amp; this.type === tt.name) {
        id = this.parseIdent()
        if (this.canInsertSemicolon() || !this.eat(tt.arrow))
          this.unexpected()
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case tt.regexp:
    var value = this.value
    node = this.parseLiteral(value.value)
    node.regex = {pattern: value.pattern, flags: value.flags}
    return node

  case tt.num: case tt.string:
    return this.parseLiteral(this.value)

  case tt._null: case tt._true: case tt._false:
    node = this.startNode()
    node.value = this.type === tt._null ? null : this.type === tt._true
    node.raw = this.type.keyword
    this.next()
    return this.finishNode(node, "Literal")

  case tt.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign &lt; 0 &amp;&amp; !this.isSimpleAssignTarget(expr))
        refDestructuringErrors.parenthesizedAssign = start
      if (refDestructuringErrors.parenthesizedBind &lt; 0)
        refDestructuringErrors.parenthesizedBind = start
    }
    return expr

  case tt.bracketL:
    node = this.startNode()
    this.next()
    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
    return this.finishNode(node, "ArrayExpression")

  case tt.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case tt._function:
    node = this.startNode()
    this.next()
    return this.parseFunction(node, false)

  case tt._class:
    return this.parseClass(this.startNode(), false)

  case tt._new:
    return this.parseNew()

  case tt.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprList" id="apidoc.element.acorn.Parser.prototype.parseExprList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprList
        <span class="apidocSignatureSpan">(close, allowTrailingComma, allowEmpty, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (allowTrailingComma &amp;&amp; this$1.afterTrailingComma(close)) break
    } else first = false

    var elt
    if (allowEmpty &amp;&amp; this$1.type === tt.comma)
      elt = null
    else if (this$1.type === tt.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors)
      if (refDestructuringErrors &amp;&amp; this$1.type === tt.comma &amp;&amp; refDestructuringErrors.trailingComma &lt; 0)
        refDestructuringErrors.trailingComma = this$1.start
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
    }
    elts.push(elt)
  }
  return elts
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprOp" id="apidoc.element.acorn.Parser.prototype.parseExprOp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOp
        <span class="apidocSignatureSpan">(left, leftStartPos, leftStartLoc, minPrec, noIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop
  if (prec != null &amp;&amp; (!noIn || this.type !== tt._in)) {
    if (prec &gt; minPrec) {
      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND
      var op = this.value
      this.next()
      var startPos = this.start, startLoc = this.startLoc
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprOps" id="apidoc.element.acorn.Parser.prototype.parseExprOps">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprOps
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprOps = function (noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseMaybeUnary(refDestructuringErrors, false)
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  return expr.start == startPos &amp;&amp; expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -
1, noIn)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExprSubscripts" id="apidoc.element.acorn.Parser.prototype.parseExprSubscripts">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExprSubscripts
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExprSubscripts = function (refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseExprAtom(refDestructuringErrors)
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" &amp;&amp; this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
  var result = this.parseSubscripts(expr, startPos, startLoc)
  if (refDestructuringErrors &amp;&amp; result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign &gt;= result.start) refDestructuringErrors.parenthesizedAssign = -1
    if (refDestructuringErrors.parenthesizedBind &gt;= result.start) refDestructuringErrors.parenthesizedBind = -1
  }
  return result
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExpression" id="apidoc.element.acorn.Parser.prototype.parseExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpression
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpression = function (noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
  if (this.type === tt.comma) {
    var node = this.startNodeAt(startPos, startLoc)
    node.expressions = [expr]
    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseExpressionStatement" id="apidoc.element.acorn.Parser.prototype.parseExpressionStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseExpressionStatement
        <span class="apidocSignatureSpan">(node, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseExpressionStatement = function (node, expr) {
  node.expression = expr
  this.semicolon()
  return this.finishNode(node, "ExpressionStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFor" id="apidoc.element.acorn.Parser.prototype.parseFor">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFor
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFor = function (node, init) {
  node.init = init
  this.expect(tt.semi)
  node.test = this.type === tt.semi ? null : this.parseExpression()
  this.expect(tt.semi)
  node.update = this.type === tt.parenR ? null : this.parseExpression()
  this.expect(tt.parenR)
  this.exitLexicalScope()
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, "ForStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseForIn" id="apidoc.element.acorn.Parser.prototype.parseForIn">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForIn
        <span class="apidocSignatureSpan">(node, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseForIn = function (node, init) {
  var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement"
  this.next()
  node.left = init
  node.right = this.parseExpression()
  this.expect(tt.parenR)
  this.exitLexicalScope()
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseForStatement" id="apidoc.element.acorn.Parser.prototype.parseForStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseForStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseForStatement = function (node) {
  this.next()
  this.labels.push(loopLabel)
  this.enterLexicalScope()
  this.expect(tt.parenL)
  if (this.type === tt.semi) return this.parseFor(node, null)
  var isLet = this.isLet()
  if (this.type === tt._var || this.type === tt._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value
    this.next()
    this.parseVar(init$1, true, kind)
    this.finishNode(init$1, "VariableDeclaration")
    if ((this.type === tt._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual("of"))) &amp;&amp; init$1.declarations.length === 1
 &amp;&amp;
        !(kind !== "var" &amp;&amp; init$1.declarations[0].init))
      return this.parseForIn(node, init$1)
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors
  var init = this.parseExpression(true, refDestructuringErrors)
  if (this.type === tt._in || (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.isContextual("of"))) {
    this.toAssignable(init)
    this.checkLVal(init)
    this.checkPatternErrors(refDestructuringErrors, true)
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true)
  }
  return this.parseFor(node, init)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunction" id="apidoc.element.acorn.Parser.prototype.parseFunction">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunction
        <span class="apidocSignatureSpan">(node, isStatement, allowExpressionBody, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node)
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; !isAsync)
    node.generator = this.eat(tt.star)
  if (this.options.ecmaVersion &gt;= 8)
    node.async = !!isAsync

  if (isStatement) {
    node.id = isStatement === "nullableID" &amp;&amp; this.type != tt.name ? null : this.parseIdent()
    if (node.id) {
      this.checkLVal(node.id, "var")
    }
  }

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction
  this.inGenerator = node.generator
  this.inAsync = node.async
  this.yieldPos = 0
  this.awaitPos = 0
  this.inFunction = true
  this.enterFunctionScope()

  if (!isStatement)
    node.id = this.type == tt.name ? this.parseIdent() : null

  this.parseFunctionParams(node)
  this.parseFunctionBody(node, allowExpressionBody)

  this.inGenerator = oldInGen
  this.inAsync = oldInAsync
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunctionBody" id="apidoc.element.acorn.Parser.prototype.parseFunctionBody">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionBody
        <span class="apidocSignatureSpan">(node, isArrowFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunctionBody = function (node, isArrowFunction) {
  var isExpression = isArrowFunction &amp;&amp; this.type !== tt.braceL
  var oldStrict = this.strict, useStrict = false

  if (isExpression) {
    node.body = this.parseMaybeAssign()
    node.expression = true
    this.checkParams(node, false)
  } else {
    var nonSimple = this.options.ecmaVersion &gt;= 7 &amp;&amp; !this.isSimpleParamList(node.params)
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end)
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict &amp;&amp; nonSimple)
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list")
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels
    this.labels = []
    if (useStrict) this.strict = true

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict &amp;&amp; !useStrict &amp;&amp; !isArrowFunction &amp;&amp; this.isSimpleParamList(node.params))
    node.body = this.parseBlock(false)
    node.expression = false
    this.labels = oldLabels
  }
  this.exitFunctionScope()

  if (this.strict &amp;&amp; node.id) {
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    this.checkLVal(node.id, "none")
  }
  this.strict = oldStrict
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunctionParams" id="apidoc.element.acorn.Parser.prototype.parseFunctionParams">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionParams
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunctionParams = function (node) {
  this.expect(tt.parenL)
  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion &gt;= 8, true)
  this.checkYieldAwaitInDefaultParams()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseFunctionStatement" id="apidoc.element.acorn.Parser.prototype.parseFunctionStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseFunctionStatement
        <span class="apidocSignatureSpan">(node, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseFunctionStatement = function (node, isAsync) {
  this.next()
  return this.parseFunction(node, true, false, isAsync)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseIdent" id="apidoc.element.acorn.Parser.prototype.parseIdent">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIdent
        <span class="apidocSignatureSpan">(liberal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseIdent = function (liberal) {
  var node = this.startNode()
  if (liberal &amp;&amp; this.options.allowReserved == "never") liberal = false
  if (this.type === tt.name) {
    if (!liberal &amp;&amp; (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &amp;&amp;
        (this.options.ecmaVersion &gt;= 6 ||
         this.input.slice(this.start, this.end).indexOf("\\") == -1))
      this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved")
    if (this.inGenerator &amp;&amp; this.value === "yield")
      this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator")
    if (this.inAsync &amp;&amp; this.value === "await")
      this.raiseRecoverable(this.start, "Can not use 'await' as identifier inside an async function")
    node.name = this.value
  } else if (liberal &amp;&amp; this.type.keyword) {
    node.name = this.type.keyword
  } else {
    this.unexpected()
  }
  this.next()
  return this.finishNode(node, "Identifier")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseIfStatement" id="apidoc.element.acorn.Parser.prototype.parseIfStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseIfStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseIfStatement = function (node) {
  this.next()
  node.test = this.parseParenExpression()
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict &amp;&amp; this.isFunction())
  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict &amp;&amp; this.isFunction()) : null
  return this.finishNode(node, "IfStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseImport" id="apidoc.element.acorn.Parser.prototype.parseImport">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImport
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseImport = function (node) {
  this.next()
  // import '...'
  if (this.type === tt.string) {
    node.specifiers = empty
    node.source = this.parseExprAtom()
  } else {
    node.specifiers = this.parseImportSpecifiers()
    this.expectContextual("from")
    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
  }
  this.semicolon()
  return this.finishNode(node, "ImportDeclaration")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseImportSpecifiers" id="apidoc.element.acorn.Parser.prototype.parseImportSpecifiers">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseImportSpecifiers
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseImportSpecifiers = function () {
  var this$1 = this;

  var nodes = [], first = true
  if (this.type === tt.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode()
    node.local = this.parseIdent()
    this.checkLVal(node.local, "let")
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"))
    if (!this.eat(tt.comma)) return nodes
  }
  if (this.type === tt.star) {
    var node$1 = this.startNode()
    this.next()
    this.expectContextual("as")
    node$1.local = this.parseIdent()
    this.checkLVal(node$1.local, "let")
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"))
    return nodes
  }
  this.expect(tt.braceL)
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false

    var node$2 = this$1.startNode()
    node$2.imported = this$1.parseIdent(true)
    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent()
    } else {
      node$2.local = node$2.imported
      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)
      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, "The keyword '" + node
$2.local.name + "' is reserved")
    }
    this$1.checkLVal(node$2.local, "let")
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"))
  }
  return nodes
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseLabeledStatement" id="apidoc.element.acorn.Parser.prototype.parseLabeledStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLabeledStatement
        <span class="apidocSignatureSpan">(node, maybeName, expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseLabeledStatement = function (node, maybeName, expr) {
  var this$1 = this;

  for (var i = 0; i &lt; this.labels.length; ++i)
    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, "Label '" + maybeName + "' is already declared")
  var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null
  for (var i$1 = this.labels.length - 1; i$1 &gt;= 0; i$1--) {
    var label = this$1.labels[i$1]
    if (label.statementStart == node.start) {
      label.statementStart = this$1.start
      label.kind = kind
    } else break
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})
  node.body = this.parseStatement(true)
  if (node.body.type == "ClassDeclaration" ||
      node.body.type == "VariableDeclaration" &amp;&amp; node.body.kind != "var" ||
      node.body.type == "FunctionDeclaration" &amp;&amp; (this.strict || node.body.generator))
    this.raiseRecoverable(node.body.start, "Invalid labeled declaration")
  this.labels.pop()
  node.label = expr
  return this.finishNode(node, "LabeledStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseLiteral" id="apidoc.element.acorn.Parser.prototype.parseLiteral">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseLiteral
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseLiteral = function (value) {
  var node = this.startNode()
  node.value = value
  node.raw = this.input.slice(this.start, this.end)
  this.next()
  return this.finishNode(node, "Literal")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeAssign" id="apidoc.element.acorn.Parser.prototype.parseMaybeAssign">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeAssign
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors, afterLeftParse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator &amp;&amp; this.isContextual("yield")) return this.parseYield()

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign
    oldTrailingComma = refDestructuringErrors.trailingComma
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1
  } else {
    refDestructuringErrors = new DestructuringErrors
    ownDestructuringErrors = true
  }

  var startPos = this.start, startLoc = this.startLoc
  if (this.type == tt.parenL || this.type == tt.name)
    this.potentialArrowAt = this.start
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
  if (this.type.isAssign) {
    this.checkPatternErrors(refDestructuringErrors, true)
    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)
    var node = this.startNodeAt(startPos, startLoc)
    node.operator = this.value
    node.left = this.type === tt.eq ? this.toAssignable(left) : left
    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly
    this.checkLVal(left)
    this.next()
    node.right = this.parseMaybeAssign(noIn)
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)
  }
  if (oldParenAssign &gt; -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign
  if (oldTrailingComma &gt; -1) refDestructuringErrors.trailingComma = oldTrailingComma
  return left
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeConditional" id="apidoc.element.acorn.Parser.prototype.parseMaybeConditional">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeConditional
        <span class="apidocSignatureSpan">(noIn, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeConditional = function (noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc
  var expr = this.parseExprOps(noIn, refDestructuringErrors)
  if (this.checkExpressionErrors(refDestructuringErrors)) return expr
  if (this.eat(tt.question)) {
    var node = this.startNodeAt(startPos, startLoc)
    node.test = expr
    node.consequent = this.parseMaybeAssign()
    this.expect(tt.colon)
    node.alternate = this.parseMaybeAssign(noIn)
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeDefault" id="apidoc.element.acorn.Parser.prototype.parseMaybeDefault">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeDefault
        <span class="apidocSignatureSpan">(startPos, startLoc, left)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeDefault = function (startPos, startLoc, left) {
  left = left || this.parseBindingAtom()
  if (this.options.ecmaVersion &lt; 6 || !this.eat(tt.eq)) return left
  var node = this.startNodeAt(startPos, startLoc)
  node.left = left
  node.right = this.parseMaybeAssign()
  return this.finishNode(node, "AssignmentPattern")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMaybeUnary" id="apidoc.element.acorn.Parser.prototype.parseMaybeUnary">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMaybeUnary
        <span class="apidocSignatureSpan">(refDestructuringErrors, sawUnary)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMaybeUnary = function (refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr
  if (this.inAsync &amp;&amp; this.isContextual("await")) {
    expr = this.parseAwait(refDestructuringErrors)
    sawUnary = true
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === tt.incDec
    node.operator = this.value
    node.prefix = true
    this.next()
    node.argument = this.parseMaybeUnary(null, true)
    this.checkExpressionErrors(refDestructuringErrors, true)
    if (update) this.checkLVal(node.argument)
    else if (this.strict &amp;&amp; node.operator === "delete" &amp;&amp;
             node.argument.type === "Identifier")
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode")
    else sawUnary = true
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors)
    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
    while (this.type.postfix &amp;&amp; !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc)
      node$1.operator = this$1.value
      node$1.prefix = false
      node$1.argument = expr
      this$1.checkLVal(expr)
      this$1.next()
      expr = this$1.finishNode(node$1, "UpdateExpression")
    }
  }

  if (!sawUnary &amp;&amp; this.eat(tt.starstar))
    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false)
  else
    return expr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseMethod" id="apidoc.element.acorn.Parser.prototype.parseMethod">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseMethod
        <span class="apidocSignatureSpan">(isGenerator, isAsync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction

  this.initFunction(node)
  if (this.options.ecmaVersion &gt;= 6)
    node.generator = isGenerator
  if (this.options.ecmaVersion &gt;= 8)
    node.async = !!isAsync

  this.inGenerator = node.generator
  this.inAsync = node.async
  this.yieldPos = 0
  this.awaitPos = 0
  this.inFunction = true
  this.enterFunctionScope()

  this.expect(tt.parenL)
  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion &gt;= 8)
  this.checkYieldAwaitInDefaultParams()
  this.parseFunctionBody(node, false)

  this.inGenerator = oldInGen
  this.inAsync = oldInAsync
  this.yieldPos = oldYieldPos
  this.awaitPos = oldAwaitPos
  this.inFunction = oldInFunc
  return this.finishNode(node, "FunctionExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseNew" id="apidoc.element.acorn.Parser.prototype.parseNew">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseNew
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseNew = function () {
  var node = this.startNode()
  var meta = this.parseIdent(true)
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.eat(tt.dot)) {
    node.meta = meta
    node.property = this.parseIdent(true)
    if (node.property.name !== "target")
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target")
    if (!this.inFunction)
      this.raiseRecoverable(node.start, "new.target can only be used in functions")
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion &gt;= 8, false)
  else node.arguments = empty$1
  return this.finishNode(node, "NewExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseObj" id="apidoc.element.acorn.Parser.prototype.parseObj">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseObj
        <span class="apidocSignatureSpan">(isPattern, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseObj = function (isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {}
  node.properties = []
  this.next()
  while (!this.eat(tt.braceR)) {
    if (!first) {
      this$1.expect(tt.comma)
      if (this$1.afterTrailingComma(tt.braceR)) break
    } else first = false

    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc
    if (this$1.options.ecmaVersion &gt;= 6) {
      prop.method = false
      prop.shorthand = false
      if (isPattern || refDestructuringErrors) {
        startPos = this$1.start
        startLoc = this$1.startLoc
      }
      if (!isPattern)
        isGenerator = this$1.eat(tt.star)
    }
    this$1.parsePropertyName(prop)
    if (!isPattern &amp;&amp; this$1.options.ecmaVersion &gt;= 8 &amp;&amp; !isGenerator &amp;&amp; !prop.computed &amp;&amp;
        prop.key.type === "Identifier" &amp;&amp; prop.key.name === "async" &amp;&amp; this$1.type !== tt.parenL &amp;&amp;
        this$1.type !== tt.colon &amp;&amp; !this$1.canInsertSemicolon()) {
      isAsync = true
      this$1.parsePropertyName(prop, refDestructuringErrors)
    } else {
      isAsync = false
    }
    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)
    this$1.checkPropClash(prop, propHash)
    node.properties.push(this$1.finishNode(prop, "Property"))
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenAndDistinguishExpression" id="apidoc.element.acorn.Parser.prototype.parseParenAndDistinguishExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenAndDistinguishExpression
        <span class="apidocSignatureSpan">(canBeArrow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenAndDistinguishExpression = function (canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion &gt;= 8
  if (this.options.ecmaVersion &gt;= 6) {
    this.next()

    var innerStartPos = this.start, innerStartLoc = this.startLoc
    var exprList = [], first = true, lastIsComma = false
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart,
innerParenStart
    this.yieldPos = 0
    this.awaitPos = 0
    while (this.type !== tt.parenR) {
      first ? first = false : this$1.expect(tt.comma)
      if (allowTrailingComma &amp;&amp; this$1.afterTrailingComma(tt.parenR, true)) {
        lastIsComma = true
        break
      } else if (this$1.type === tt.ellipsis) {
        spreadStart = this$1.start
        exprList.push(this$1.parseParenItem(this$1.parseRest()))
        if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element")
        break
      } else {
        if (this$1.type === tt.parenL &amp;&amp; !innerParenStart) {
          innerParenStart = this$1.start
        }
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc
    this.expect(tt.parenR)

    if (canBeArrow &amp;&amp; !this.canInsertSemicolon() &amp;&amp; this.eat(tt.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false)
      this.checkYieldAwaitInDefaultParams()
      if (innerParenStart) this.unexpected(innerParenStart)
      this.yieldPos = oldYieldPos
      this.awaitPos = oldAwaitPos
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)
    if (spreadStart) this.unexpected(spreadStart)
    this.checkExpressionErrors(refDestructuringErrors, true)
    this.yieldPos = oldYieldPos || this.yieldPos
    this.awaitPos = oldAwaitPos || this.awaitPos

    if (exprList.length &gt; 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc)
      val.expressions = exprList
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)
    } else {
      val = exprList[0]
    }
  } else {
    val = this.parseParenExpression()
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc)
    par.expression = val
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenArrowList" id="apidoc.element.acorn.Parser.prototype.parseParenArrowList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenArrowList
        <span class="apidocSignatureSpan">(startPos, startLoc, exprList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenArrowList = function (startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenExpression" id="apidoc.element.acorn.Parser.prototype.parseParenExpression">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenExpression = function () {
  this.expect(tt.parenL)
  var val = this.parseExpression()
  this.expect(tt.parenR)
  return val
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseParenItem" id="apidoc.element.acorn.Parser.prototype.parseParenItem">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseParenItem
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseParenItem = function (item) {
  return item
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parsePropertyName" id="apidoc.element.acorn.Parser.prototype.parsePropertyName">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyName
        <span class="apidocSignatureSpan">(prop)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropertyName = function (prop) {
  if (this.options.ecmaVersion &gt;= 6) {
    if (this.eat(tt.bracketL)) {
      prop.computed = true
      prop.key = this.parseMaybeAssign()
      this.expect(tt.bracketR)
      return prop.key
    } else {
      prop.computed = false
    }
  }
  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parsePropertyValue" id="apidoc.element.acorn.Parser.prototype.parsePropertyValue">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parsePropertyValue
        <span class="apidocSignatureSpan">(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
  if ((isGenerator || isAsync) &amp;&amp; this.type === tt.colon)
    this.unexpected()

  if (this.eat(tt.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors
)
    prop.kind = "init"
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; this.type === tt.parenL) {
    if (isPattern) this.unexpected()
    prop.kind = "init"
    prop.method = true
    prop.value = this.parseMethod(isGenerator, isAsync)
  } else if (this.options.ecmaVersion &gt;= 5 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === "Identifier" &amp;&amp;
             (prop.key.name === "get" || prop.key.name === "set") &amp;&amp;
             (this.type != tt.comma &amp;&amp; this.type != tt.braceR)) {
    if (isGenerator || isAsync || isPattern) this.unexpected()
    prop.kind = prop.key.name
    this.parsePropertyName(prop)
    prop.value = this.parseMethod(false)
    var paramCount = prop.kind === "get" ? 0 : 1
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start
      if (prop.kind === "get")
        this.raiseRecoverable(start, "getter should have no params")
      else
        this.raiseRecoverable(start, "setter should have exactly one param")
    } else {
      if (prop.kind === "set" &amp;&amp; prop.value.params[0].type === "RestElement")
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params")
    }
  } else if (this.options.ecmaVersion &gt;= 6 &amp;&amp; !prop.computed &amp;&amp; prop.key.type === "Identifier") {
    if (this.keywords.test(prop.key.name) ||
        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||
        (this.inGenerator &amp;&amp; prop.key.name == "yield") ||
        (this.inAsync &amp;&amp; prop.key.name == "await"))
      this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property")
    prop.kind = "init"
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
    } else if (this.type === tt.eq &amp;&amp; refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign &lt; 0)
        refDestructuringErrors.shorthandAssign = this.start
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
    } else {
      prop.value = prop.key
    }
    prop.shorthand = true
  } else this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseRest" id="apidoc.element.acorn.Parser.prototype.parseRest">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseRest
        <span class="apidocSignatureSpan">(allowNonIdent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseRest = function (allowNonIdent) {
  var node = this.startNode()
  this.next()

  // RestElement inside of a function parameter must be an identifier
  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()
  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()

  return this.finishNode(node, "RestElement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseReturnStatement" id="apidoc.element.acorn.Parser.prototype.parseReturnStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseReturnStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseReturnStatement = function (node) {
  if (!this.inFunction &amp;&amp; !this.options.allowReturnOutsideFunction)
    this.raise(this.start, "'return' outside of function")
  this.next()

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null
  else { node.argument = this.parseExpression(); this.semicolon() }
  return this.finishNode(node, "ReturnStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseSpread" id="apidoc.element.acorn.Parser.prototype.parseSpread">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSpread
        <span class="apidocSignatureSpan">(refDestructuringErrors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSpread = function (refDestructuringErrors) {
  var node = this.startNode()
  this.next()
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)
  return this.finishNode(node, "SpreadElement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseStatement" id="apidoc.element.acorn.Parser.prototype.parseStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseStatement
        <span class="apidocSignatureSpan">(declaration, topLevel, exports)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseStatement = function (declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind

  if (this.isLet()) {
    starttype = tt._var
    kind = "let"
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case tt._debugger: return this.parseDebuggerStatement(node)
  case tt._do: return this.parseDoStatement(node)
  case tt._for: return this.parseForStatement(node)
  case tt._function:
    if (!declaration &amp;&amp; this.options.ecmaVersion &gt;= 6) this.unexpected()
    return this.parseFunctionStatement(node, false)
  case tt._class:
    if (!declaration) this.unexpected()
    return this.parseClass(node, true)
  case tt._if: return this.parseIfStatement(node)
  case tt._return: return this.parseReturnStatement(node)
  case tt._switch: return this.parseSwitchStatement(node)
  case tt._throw: return this.parseThrowStatement(node)
  case tt._try: return this.parseTryStatement(node)
  case tt._const: case tt._var:
    kind = kind || this.value
    if (!declaration &amp;&amp; kind != "var") this.unexpected()
    return this.parseVarStatement(node, kind)
  case tt._while: return this.parseWhileStatement(node)
  case tt._with: return this.parseWithStatement(node)
  case tt.braceL: return this.parseBlock()
  case tt.semi: return this.parseEmptyStatement(node)
  case tt._export:
  case tt._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        this.raise(this.start, "'import' and 'export' may only appear at the top level")
      if (!this.inModule)
        this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")
    }
    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction() &amp;&amp; declaration) {
      this.next()
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression()
    if (starttype === tt.name &amp;&amp; expr.type === "Identifier" &amp;&amp; this.eat(tt.colon))
      return this.parseLabeledStatement(node, maybeName, expr)
    else return this.parseExpressionStatement(node, expr)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseSubscripts" id="apidoc.element.acorn.Parser.prototype.parseSubscripts">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSubscripts
        <span class="apidocSignatureSpan">(base, startPos, startLoc, noCalls)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSubscripts = function (base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion &gt;= 8 &amp;&amp; base.type === "Identifier" &amp;&amp; base.name === "async" &amp;&amp;
      this.lastTokEnd == base.end &amp;&amp; !this.canInsertSemicolon()
  for (var computed;;) {
    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc)
      node.object = base
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)
      node.computed = !!computed
      if (computed) this$1.expect(tt.bracketR)
      base = this$1.finishNode(node, "MemberExpression")
    } else if (!noCalls &amp;&amp; this$1.eat(tt.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos
      this$1.yieldPos = 0
      this$1.awaitPos = 0
      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion &gt;= 8, false, refDestructuringErrors)
      if (maybeAsyncArrow &amp;&amp; !this$1.canInsertSemicolon() &amp;&amp; this$1.eat(tt.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false)
        this$1.checkYieldAwaitInDefaultParams()
        this$1.yieldPos = oldYieldPos
        this$1.awaitPos = oldAwaitPos
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true)
      this$1.yieldPos = oldYieldPos || this$1.yieldPos
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos
      var node$1 = this$1.startNodeAt(startPos, startLoc)
      node$1.callee = base
      node$1.arguments = exprList
      base = this$1.finishNode(node$1, "CallExpression")
    } else if (this$1.type === tt.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc)
      node$2.tag = base
      node$2.quasi = this$1.parseTemplate()
      base = this$1.finishNode(node$2, "TaggedTemplateExpression")
    } else {
      return base
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseSwitchStatement" id="apidoc.element.acorn.Parser.prototype.parseSwitchStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseSwitchStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseSwitchStatement = function (node) {
  var this$1 = this;

  this.next()
  node.discriminant = this.parseParenExpression()
  node.cases = []
  this.expect(tt.braceL)
  this.labels.push(switchLabel)
  this.enterLexicalScope()

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur
  for (var sawDefault = false; this.type != tt.braceR;) {
    if (this$1.type === tt._case || this$1.type === tt._default) {
      var isCase = this$1.type === tt._case
      if (cur) this$1.finishNode(cur, "SwitchCase")
      node.cases.push(cur = this$1.startNode())
      cur.consequent = []
      this$1.next()
      if (isCase) {
        cur.test = this$1.parseExpression()
      } else {
        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses")
        sawDefault = true
        cur.test = null
      }
      this$1.expect(tt.colon)
    } else {
      if (!cur) this$1.unexpected()
      cur.consequent.push(this$1.parseStatement(true))
    }
  }
  this.exitLexicalScope()
  if (cur) this.finishNode(cur, "SwitchCase")
  this.next() // Closing brace
  this.labels.pop()
  return this.finishNode(node, "SwitchStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTemplate" id="apidoc.element.acorn.Parser.prototype.parseTemplate">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTemplate = function () {
  var this$1 = this;

  var node = this.startNode()
  this.next()
  node.expressions = []
  var curElt = this.parseTemplateElement()
  node.quasis = [curElt]
  while (!curElt.tail) {
    this$1.expect(tt.dollarBraceL)
    node.expressions.push(this$1.parseExpression())
    this$1.expect(tt.braceR)
    node.quasis.push(curElt = this$1.parseTemplateElement())
  }
  this.next()
  return this.finishNode(node, "TemplateLiteral")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTemplateElement" id="apidoc.element.acorn.Parser.prototype.parseTemplateElement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTemplateElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTemplateElement = function () {
  var elem = this.startNode()
  elem.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
    cooked: this.value
  }
  this.next()
  elem.tail = this.type === tt.backQuote
  return this.finishNode(elem, "TemplateElement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseThrowStatement" id="apidoc.element.acorn.Parser.prototype.parseThrowStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseThrowStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseThrowStatement = function (node) {
  this.next()
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    this.raise(this.lastTokEnd, "Illegal newline after throw")
  node.argument = this.parseExpression()
  this.semicolon()
  return this.finishNode(node, "ThrowStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTopLevel" id="apidoc.element.acorn.Parser.prototype.parseTopLevel">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTopLevel
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTopLevel = function (node) {
  var this$1 = this;

  var exports = {}
  if (!node.body) node.body = []
  while (this.type !== tt.eof) {
    var stmt = this$1.parseStatement(true, true, exports)
    node.body.push(stmt)
  }
  this.next()
  if (this.options.ecmaVersion &gt;= 6) {
    node.sourceType = this.options.sourceType
  }
  return this.finishNode(node, "Program")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseTryStatement" id="apidoc.element.acorn.Parser.prototype.parseTryStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseTryStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseTryStatement = function (node) {
  this.next()
  node.block = this.parseBlock()
  node.handler = null
  if (this.type === tt._catch) {
    var clause = this.startNode()
    this.next()
    this.expect(tt.parenL)
    clause.param = this.parseBindingAtom()
    this.enterLexicalScope()
    this.checkLVal(clause.param, "let")
    this.expect(tt.parenR)
    clause.body = this.parseBlock(false)
    this.exitLexicalScope()
    node.handler = this.finishNode(clause, "CatchClause")
  }
  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
  if (!node.handler &amp;&amp; !node.finalizer)
    this.raise(node.start, "Missing catch or finally clause")
  return this.finishNode(node, "TryStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseVar" id="apidoc.element.acorn.Parser.prototype.parseVar">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVar
        <span class="apidocSignatureSpan">(node, isFor, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseVar = function (node, isFor, kind) {
  var this$1 = this;

  node.declarations = []
  node.kind = kind
  for (;;) {
    var decl = this$1.startNode()
    this$1.parseVarId(decl, kind)
    if (this$1.eat(tt.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor)
    } else if (kind === "const" &amp;&amp; !(this$1.type === tt._in || (this$1.options.ecmaVersion &gt;= 6 &amp;&amp; this$1.isContextual("of")))) {
      this$1.unexpected()
    } else if (decl.id.type != "Identifier" &amp;&amp; !(isFor &amp;&amp; (this$1.type === tt._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value")
    } else {
      decl.init = null
    }
    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"))
    if (!this$1.eat(tt.comma)) break
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseVarId" id="apidoc.element.acorn.Parser.prototype.parseVarId">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarId
        <span class="apidocSignatureSpan">(decl, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseVarId = function (decl, kind) {
  decl.id = this.parseBindingAtom(kind)
  this.checkLVal(decl.id, kind, false)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseVarStatement" id="apidoc.element.acorn.Parser.prototype.parseVarStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseVarStatement
        <span class="apidocSignatureSpan">(node, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseVarStatement = function (node, kind) {
  this.next()
  this.parseVar(node, false, kind)
  this.semicolon()
  return this.finishNode(node, "VariableDeclaration")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseWhileStatement" id="apidoc.element.acorn.Parser.prototype.parseWhileStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWhileStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWhileStatement = function (node) {
  this.next()
  node.test = this.parseParenExpression()
  this.labels.push(loopLabel)
  node.body = this.parseStatement(false)
  this.labels.pop()
  return this.finishNode(node, "WhileStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseWithStatement" id="apidoc.element.acorn.Parser.prototype.parseWithStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseWithStatement
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseWithStatement = function (node) {
  if (this.strict) this.raise(this.start, "'with' in strict mode")
  this.next()
  node.object = this.parseParenExpression()
  node.body = this.parseStatement(false)
  return this.finishNode(node, "WithStatement")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.parseYield" id="apidoc.element.acorn.Parser.prototype.parseYield">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>parseYield
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseYield = function () {
  if (!this.yieldPos) this.yieldPos = this.start

  var node = this.startNode()
  this.next()
  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star &amp;&amp; !this.type.startsExpr)) {
    node.delegate = false
    node.argument = null
  } else {
    node.delegate = this.eat(tt.star)
    node.argument = this.parseMaybeAssign()
  }
  return this.finishNode(node, "YieldExpression")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.raise" id="apidoc.element.acorn.Parser.prototype.raise">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raise
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos)
  message += " (" + loc.line + ":" + loc.column + ")"
  var err = new SyntaxError(message)
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos
  throw err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.raiseRecoverable" id="apidoc.element.acorn.Parser.prototype.raiseRecoverable">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>raiseRecoverable
        <span class="apidocSignatureSpan">(pos, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">raiseRecoverable = function (pos, message) {
  var loc = getLineInfo(this.input, pos)
  message += " (" + loc.line + ":" + loc.column + ")"
  var err = new SyntaxError(message)
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos
  throw err
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readCodePoint" id="apidoc.element.acorn.Parser.prototype.readCodePoint">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readCodePoint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readCodePoint = function () {
  var ch = this.input.charCodeAt(this.pos), code

  if (ch === 123) {
    if (this.options.ecmaVersion &lt; 6) this.unexpected()
    var codePos = ++this.pos
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos)
    ++this.pos
    if (code &gt; 0x10FFFF) this.raise(codePos, "Code point out of bounds")
  } else {
    code = this.readHexChar(4)
  }
  return code
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readEscapedChar" id="apidoc.element.acorn.Parser.prototype.readEscapedChar">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readEscapedChar
        <span class="apidocSignatureSpan">(inTemplate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readEscapedChar = function (inTemplate) {
  var ch = this.input.charCodeAt(++this.pos)
  ++this.pos
  switch (ch) {
  case 110: return "\n" // 'n' -&gt; '\n'
  case 114: return "\r" // 'r' -&gt; '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -&gt; '\t'
  case 98: return "\b" // 'b' -&gt; '\b'
  case 118: return "\u000b" // 'v' -&gt; '\u000b'
  case 102: return "\f" // 'f' -&gt; '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
    return ""
  default:
    if (ch &gt;= 48 &amp;&amp; ch &lt;= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]
      var octal = parseInt(octalStr, 8)
      if (octal &gt; 255) {
        octalStr = octalStr.slice(0, -1)
        octal = parseInt(octalStr, 8)
      }
      if (octalStr !== "0" &amp;&amp; (this.strict || inTemplate)) {
        this.raise(this.pos - 2, "Octal literal in strict mode")
      }
      this.pos += octalStr.length - 1
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readHexChar" id="apidoc.element.acorn.Parser.prototype.readHexChar">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readHexChar
        <span class="apidocSignatureSpan">(len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readHexChar = function (len) {
  var codePos = this.pos
  var n = this.readInt(16, len)
  if (n === null) this.raise(codePos, "Bad character escape sequence")
  return n
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readInt" id="apidoc.element.acorn.Parser.prototype.readInt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readInt
        <span class="apidocSignatureSpan">(radix, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readInt = function (radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0
  for (var i = 0, e = len == null ? Infinity : len; i &lt; e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val
    if (code &gt;= 97) val = code - 97 + 10 // a
    else if (code &gt;= 65) val = code - 65 + 10 // A
    else if (code &gt;= 48 &amp;&amp; code &lt;= 57) val = code - 48 // 0-9
    else val = Infinity
    if (val &gt;= radix) break
    ++this$1.pos
    total = total * radix + val
  }
  if (this.pos === start || len != null &amp;&amp; this.pos - start !== len) return null

  return total
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readNumber" id="apidoc.element.acorn.Parser.prototype.readNumber">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readNumber
        <span class="apidocSignatureSpan">(startsWithDot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readNumber = function (startsWithDot) {
  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48
  if (!startsWithDot &amp;&amp; this.readInt(10) === null) this.raise(start, "Invalid number")
  if (octal &amp;&amp; this.pos == start + 1) octal = false
  var next = this.input.charCodeAt(this.pos)
  if (next === 46 &amp;&amp; !octal) { // '.'
    ++this.pos
    this.readInt(10)
    isFloat = true
    next = this.input.charCodeAt(this.pos)
  }
  if ((next === 69 || next === 101) &amp;&amp; !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos)
    if (next === 43 || next === 45) ++this.pos // '+-'
    if (this.readInt(10) === null) this.raise(start, "Invalid number")
    isFloat = true
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")

  var str = this.input.slice(start, this.pos), val
  if (isFloat) val = parseFloat(str)
  else if (!octal || str.length === 1) val = parseInt(str, 10)
  else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number")
  else val = parseInt(str, 8)
  return this.finishToken(tt.num, val)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readRadixNumber" id="apidoc.element.acorn.Parser.prototype.readRadixNumber">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRadixNumber
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readRadixNumber = function (radix) {
  this.pos += 2 // 0x
  var val = this.readInt(radix)
  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix)
  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
  return this.finishToken(tt.num, val)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readRegexp" id="apidoc.element.acorn.Parser.prototype.readRegexp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readRegexp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readRegexp = function () {
  var this$1 = this;

  var escaped, inClass, start = this.pos
  for (;;) {
    if (this$1.pos &gt;= this$1.input.length) this$1.raise(start, "Unterminated regular expression")
    var ch = this$1.input.charAt(this$1.pos)
    if (lineBreak.test(ch)) this$1.raise(start, "Unterminated regular expression")
    if (!escaped) {
      if (ch === "[") inClass = true
      else if (ch === "]" &amp;&amp; inClass) inClass = false
      else if (ch === "/" &amp;&amp; !inClass) break
      escaped = ch === "\\"
    } else escaped = false
    ++this$1.pos
  }
  var content = this.input.slice(start, this.pos)
  ++this.pos
  // Need to use `readWord1` because '\uXXXX' sequences are allowed
  // here (don't ask).
  var mods = this.readWord1()
  var tmp = content, tmpFlags = ""
  if (mods) {
    var validFlags = /^[gim]*$/
    if (this.options.ecmaVersion &gt;= 6) validFlags = /^[gimuy]*$/
    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag")
    if (mods.indexOf("u") &gt;= 0) {
      if (regexpUnicodeSupport) {
        tmpFlags = "u"
      } else {
        // Replace each astral symbol and every Unicode escape sequence that
        // possibly represents an astral symbol or a paired surrogate with a
        // single ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        // Note: replacing with the ASCII symbol `x` might cause false
        // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
        // perfectly valid pattern that is equivalent to `[a-b]`, but it would
        // be replaced by `[x-b]` which throws an error.
        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
          code = Number("0x" + code)
          if (code &gt; 0x10FFFF) this$1.raise(start + offset + 3, "Code point out of bounds")
          return "x"
        })
        tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x")
        tmpFlags = tmpFlags.replace("u", "")
      }
    }
  }
  // Detect invalid regular expressions.
  var value = null
  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
  // so don't do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, tmpFlags, start, this)
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    value = tryCreateRegexp(content, mods)
  }
  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readString" id="apidoc.element.acorn.Parser.prototype.readString">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readString
        <span class="apidocSignatureSpan">(quote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readString = function (quote) {
  var this$1 = this;

  var out = "", chunkStart = ++this.pos
  for (;;) {
    if (this$1.pos &gt;= this$1.input.length) this$1.raise(this$1.start, "Unterminated string constant")
    var ch = this$1.input.charCodeAt(this$1.pos)
    if (ch === quote) break
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos)
      out += this$1.readEscapedChar(false)
      chunkStart = this$1.pos
    } else {
      if (isNewLine(ch)) this$1.raise(this$1.start, "Unterminated string constant")
      ++this$1.pos
    }
  }
  out += this.input.slice(chunkStart, this.pos++)
  return this.finishToken(tt.string, out)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readTmplToken" id="apidoc.element.acorn.Parser.prototype.readTmplToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readTmplToken
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readTmplToken = function () {
  var this$1 = this;

  var out = "", chunkStart = this.pos
  for (;;) {
    if (this$1.pos &gt;= this$1.input.length) this$1.raise(this$1.start, "Unterminated template")
    var ch = this$1.input.charCodeAt(this$1.pos)
    if (ch === 96 || ch === 36 &amp;&amp; this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
      if (this$1.pos === this$1.start &amp;&amp; this$1.type === tt.template) {
        if (ch === 36) {
          this$1.pos += 2
          return this$1.finishToken(tt.dollarBraceL)
        } else {
          ++this$1.pos
          return this$1.finishToken(tt.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos)
      return this$1.finishToken(tt.template, out)
    }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos)
      out += this$1.readEscapedChar(true)
      chunkStart = this$1.pos
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos)
      ++this$1.pos
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos
      case 10:
        out += "\n"
        break
      default:
        out += String.fromCharCode(ch)
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine
        this$1.lineStart = this$1.pos
      }
      chunkStart = this$1.pos
    } else {
      ++this$1.pos
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken" id="apidoc.element.acorn.Parser.prototype.readToken">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken = function (code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion &gt;= 6) || code === 92 /* '\' */)
    return this.readWord()

  return this.getTokenFromCode(code)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_caret" id="apidoc.element.acorn.Parser.prototype.readToken_caret">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_caret
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_caret = function () { // '^'
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.bitwiseXOR, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_dot" id="apidoc.element.acorn.Parser.prototype.readToken_dot">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_dot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_dot = function () {
  var next = this.input.charCodeAt(this.pos + 1)
  if (next &gt;= 48 &amp;&amp; next &lt;= 57) return this.readNumber(true)
  var next2 = this.input.charCodeAt(this.pos + 2)
  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; next === 46 &amp;&amp; next2 === 46) { // 46 = dot '.'
    this.pos += 3
    return this.finishToken(tt.ellipsis)
  } else {
    ++this.pos
    return this.finishToken(tt.dot)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_eq_excl" id="apidoc.element.acorn.Parser.prototype.readToken_eq_excl">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_eq_excl
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_eq_excl = function (code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
  if (code === 61 &amp;&amp; next === 62 &amp;&amp; this.options.ecmaVersion &gt;= 6) { // '=&gt;'
    this.pos += 2
    return this.finishToken(tt.arrow)
  }
  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_lt_gt" id="apidoc.element.acorn.Parser.prototype.readToken_lt_gt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_lt_gt
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_lt_gt = function (code) { // '&lt;&gt;'
  var next = this.input.charCodeAt(this.pos + 1)
  var size = 1
  if (next === code) {
    size = code === 62 &amp;&amp; this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2
    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
    return this.finishOp(tt.bitShift, size)
  }
  if (next == 33 &amp;&amp; code == 60 &amp;&amp; this.input.charCodeAt(this.pos + 2) == 45 &amp;&amp;
      this.input.charCodeAt(this.pos + 3) == 45) {
    if (this.inModule) this.unexpected()
    // `&lt;!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4)
    this.skipSpace()
    return this.nextToken()
  }
  if (next === 61) size = 2
  return this.finishOp(tt.relational, size)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_mult_modulo_exp" id="apidoc.element.acorn.Parser.prototype.readToken_mult_modulo_exp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_mult_modulo_exp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_mult_modulo_exp = function (code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1)
  var size = 1
  var tokentype = code === 42 ? tt.star : tt.modulo

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion &gt;= 7 &amp;&amp; next === 42) {
    ++size
    tokentype = tt.starstar
    next = this.input.charCodeAt(this.pos + 2)
  }

  if (next === 61) return this.finishOp(tt.assign, size + 1)
  return this.finishOp(tokentype, size)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_pipe_amp" id="apidoc.element.acorn.Parser.prototype.readToken_pipe_amp">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_pipe_amp
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_pipe_amp = function (code) { // '|&amp;'
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_plus_min" id="apidoc.element.acorn.Parser.prototype.readToken_plus_min">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_plus_min
        <span class="apidocSignatureSpan">(code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_plus_min = function (code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1)
  if (next === code) {
    if (next == 45 &amp;&amp; this.input.charCodeAt(this.pos + 2) == 62 &amp;&amp;
        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
      // A `--&gt;` line comment
      this.skipLineComment(3)
      this.skipSpace()
      return this.nextToken()
    }
    return this.finishOp(tt.incDec, 2)
  }
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.plusMin, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readToken_slash" id="apidoc.element.acorn.Parser.prototype.readToken_slash">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readToken_slash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readToken_slash = function () { // '/'
  var next = this.input.charCodeAt(this.pos + 1)
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) return this.finishOp(tt.assign, 2)
  return this.finishOp(tt.slash, 1)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readWord" id="apidoc.element.acorn.Parser.prototype.readWord">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readWord = function () {
  var word = this.readWord1()
  var type = tt.name
  if (this.keywords.test(word)) {
    if (this.containsEsc) this.raiseRecoverable(this.start, "Escape sequence in keyword " + word)
    type = keywordTypes[word]
  }
  return this.finishToken(type, word)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.readWord1" id="apidoc.element.acorn.Parser.prototype.readWord1">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>readWord1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readWord1 = function () {
  var this$1 = this;

  this.containsEsc = false
  var word = "", first = true, chunkStart = this.pos
  var astral = this.options.ecmaVersion &gt;= 6
  while (this.pos &lt; this.input.length) {
    var ch = this$1.fullCharCodeAtPos()
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch &lt;= 0xffff ? 1 : 2
    } else if (ch === 92) { // "\"
      this$1.containsEsc = true
      word += this$1.input.slice(chunkStart, this$1.pos)
      var escStart = this$1.pos
      if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
        this$1.raise(this$1.pos, "Expecting Unicode escape sequence \\uXXXX")
      ++this$1.pos
      var esc = this$1.readCodePoint()
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        this$1.raise(escStart, "Invalid Unicode escape")
      word += codePointToString(esc)
      chunkStart = this$1.pos
    } else {
      break
    }
    first = false
  }
  return word + this.input.slice(chunkStart, this.pos)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.semicolon" id="apidoc.element.acorn.Parser.prototype.semicolon">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>semicolon
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">semicolon = function () {
  if (!this.eat(tt.semi) &amp;&amp; !this.insertSemicolon()) this.unexpected()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.shouldParseExportStatement" id="apidoc.element.acorn.Parser.prototype.shouldParseExportStatement">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>shouldParseExportStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldParseExportStatement = function () {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.skipBlockComment" id="apidoc.element.acorn.Parser.prototype.skipBlockComment">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipBlockComment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipBlockComment = function () {
  var this$1 = this;

  var startLoc = this.options.onComment &amp;&amp; this.curPosition()
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2)
  if (end === -1) this.raise(this.pos - 2, "Unterminated comment")
  this.pos = end + 2
  if (this.options.locations) {
    lineBreakG.lastIndex = start
    var match
    while ((match = lineBreakG.exec(this.input)) &amp;&amp; match.index &lt; this.pos) {
      ++this$1.curLine
      this$1.lineStart = match.index + match[0].length
    }
  }
  if (this.options.onComment)
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.skipLineComment" id="apidoc.element.acorn.Parser.prototype.skipLineComment">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipLineComment
        <span class="apidocSignatureSpan">(startSkip)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipLineComment = function (startSkip) {
  var this$1 = this;

  var start = this.pos
  var startLoc = this.options.onComment &amp;&amp; this.curPosition()
  var ch = this.input.charCodeAt(this.pos += startSkip)
  while (this.pos &lt; this.input.length &amp;&amp; ch !== 10 &amp;&amp; ch !== 13 &amp;&amp; ch !== 8232 &amp;&amp; ch !== 8233) {
    ++this$1.pos
    ch = this$1.input.charCodeAt(this$1.pos)
  }
  if (this.options.onComment)
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition())
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.skipSpace" id="apidoc.element.acorn.Parser.prototype.skipSpace">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>skipSpace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipSpace = function () {
  var this$1 = this;

  loop: while (this.pos &lt; this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos)
    switch (ch) {
    case 32: case 160: // ' '
      ++this$1.pos
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos
      }
    case 10: case 8232: case 8233:
      ++this$1.pos
      if (this$1.options.locations) {
        ++this$1.curLine
        this$1.lineStart = this$1.pos
      }
      break
    case 47: // '/'
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // '*'
        this$1.skipBlockComment()
        break
      case 47:
        this$1.skipLineComment(2)
        break
      default:
        break loop
      }
      break
    default:
      if (ch &gt; 8 &amp;&amp; ch &lt; 14 || ch &gt;= 5760 &amp;&amp; nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos
      } else {
        break loop
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.startNode" id="apidoc.element.acorn.Parser.prototype.startNode">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startNode = function () {
  return new Node(this, this.start, this.startLoc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.startNodeAt" id="apidoc.element.acorn.Parser.prototype.startNodeAt">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>startNodeAt
        <span class="apidocSignatureSpan">(pos, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.strictDirective" id="apidoc.element.acorn.Parser.prototype.strictDirective">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>strictDirective
        <span class="apidocSignatureSpan">(start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">strictDirective = function (start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start
    start += skipWhiteSpace.exec(this$1.input)[0].length
    var match = literal.exec(this$1.input.slice(start))
    if (!match) return false
    if ((match[1] || match[2]) == "use strict") return true
    start += match[0].length
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.toAssignable" id="apidoc.element.acorn.Parser.prototype.toAssignable">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignable
        <span class="apidocSignatureSpan">(node, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAssignable = function (node, isBinding) {
  var this$1 = this;

  if (this.options.ecmaVersion &gt;= 6 &amp;&amp; node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync &amp;&amp; node.name === "await")
        this.raise(node.start, "Can not use 'await' as identifier inside an async function")
      break

    case "ObjectPattern":
    case "ArrayPattern":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern"
      for (var i = 0; i &lt; node.properties.length; i++) {
        var prop = node.properties[i]
        if (prop.kind !== "init") this$1.raise(prop.key.start, "Object pattern can't contain getter or setter")
        this$1.toAssignable(prop.value, isBinding)
      }
      break

    case "ArrayExpression":
      node.type = "ArrayPattern"
      this.toAssignableList(node.elements, isBinding)
      break

    case "AssignmentExpression":
      if (node.operator === "=") {
        node.type = "AssignmentPattern"
        delete node.operator
        this.toAssignable(node.left, isBinding)
        // falls through to AssignmentPattern
      } else {
        this.raise(node.left.end, "Only '=' operator can be used for specifying default value.")
        break
      }

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      node.expression = this.toAssignable(node.expression, isBinding)
      break

    case "MemberExpression":
      if (!isBinding) break

    default:
      this.raise(node.start, "Assigning to rvalue")
    }
  }
  return node
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.toAssignableList" id="apidoc.element.acorn.Parser.prototype.toAssignableList">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>toAssignableList
        <span class="apidocSignatureSpan">(exprList, isBinding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toAssignableList = function (exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length
  if (end) {
    var last = exprList[end - 1]
    if (last &amp;&amp; last.type == "RestElement") {
      --end
    } else if (last &amp;&amp; last.type == "SpreadElement") {
      last.type = "RestElement"
      var arg = last.argument
      this.toAssignable(arg, isBinding)
      if (arg.type !== "Identifier" &amp;&amp; arg.type !== "MemberExpression" &amp;&amp; arg.type !== "ArrayPattern")
        this.unexpected(arg.start)
      --end
    }

    if (isBinding &amp;&amp; last &amp;&amp; last.type === "RestElement" &amp;&amp; last.argument.type !== "Identifier")
      this.unexpected(last.argument.start)
  }
  for (var i = 0; i &lt; end; i++) {
    var elt = exprList[i]
    if (elt) this$1.toAssignable(elt, isBinding)
  }
  return exprList
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.unexpected" id="apidoc.element.acorn.Parser.prototype.unexpected">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>unexpected
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unexpected = function (pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.acorn.Parser.prototype.updateContext" id="apidoc.element.acorn.Parser.prototype.updateContext">
        function <span class="apidocSignatureSpan">acorn.Parser.prototype.</span>updateContext
        <span class="apidocSignatureSpan">(prevType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateContext = function (prevType) {
  var update, type = this.type
  if (type.keyword &amp;&amp; prevType == tt.dot)
    this.exprAllowed = false
  else if (update = type.updateContext)
    update.call(this, prevType)
  else
    this.exprAllowed = type.beforeExpr
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Position" id="apidoc.module.acorn.Position">module acorn.Position</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Position.Position" id="apidoc.element.acorn.Position.Position">
        function <span class="apidocSignatureSpan">acorn.</span>Position
        <span class="apidocSignatureSpan">(line, col)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Position(line, col) {
  this.line = line
  this.column = col
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.acorn.Position.prototype" id="apidoc.module.acorn.Position.prototype">module acorn.Position.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.acorn.Position.prototype.offset" id="apidoc.element.acorn.Position.prototype.offset">
        function <span class="apidocSignatureSpan">acorn.Position.prototype.</span>offset
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function offset(n) {
  return new Position(this.line, this.column + n)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>